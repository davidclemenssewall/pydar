
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>pydar package &#8212; pydar 2021 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="pydar-package">
<h1>pydar package<a class="headerlink" href="#pydar-package" title="Permalink to this headline">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</section>
<section id="module-pydar.cython_util">
<span id="pydar-cython-util-module"></span><h2>pydar.cython_util module<a class="headerlink" href="#module-pydar.cython_util" title="Permalink to this headline">¶</a></h2>
</section>
<section id="id1">
<h2>pydar.cython_util module<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-0"></span></section>
<section id="id2">
<h2>pydar.cython_util module<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-1"></span></section>
<section id="pydar-pydar-module">
<h2>pydar.pydar module<a class="headerlink" href="#pydar-pydar-module" title="Permalink to this headline">¶</a></h2>
</section>
<section id="pydar-setup-module">
<h2>pydar.setup module<a class="headerlink" href="#pydar-setup-module" title="Permalink to this headline">¶</a></h2>
</section>
<section id="module-pydar">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pydar" title="Permalink to this headline">¶</a></h2>
<p>Classes and functions for registering and displaying mosaic lidar scans.</p>
<p>In this module we take an object oriented approach to managing single scans, 
projects (collections of scans all from the same day or 2 days sometimes), 
tiepoint lists, and scan areas (collections of projects covering the same
physical regions). Each of these categories is represented by a class.</p>
<p>Created on Tue Sep  8 10:46:27 2020</p>
<p>&#64;author: d34763s</p>
<dl class="py class">
<dt class="sig sig-object py" id="pydar.ClassFilter">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">ClassFilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_connection</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">70]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ClassFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Filter points according to the classification field</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_connection</strong><span class="classifier">vtkAlgorithmOutput</span></dt><dd></dd>
<dt><strong>class_list</strong><span class="classifier">list</span></dt><dd><p>List of categories this filter will return, if special value: ‘all’
Then we do not have a selection filter and we pass through all points</p>
</dd>
<dt><strong>filter</strong><span class="classifier">vtkPolyDataAlgorithm</span></dt><dd><p>The filter</p>
</dd>
<dt><strong>selectionNode</strong><span class="classifier">vtkSelectionNode</span></dt><dd><p>Selection node object for selecting points</p>
</dd>
<dt><strong>selection</strong><span class="classifier">vtkSelection</span></dt><dd><p>selection object</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 32%" />
<col style="width: 68%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>CreateFilter(class_list)</strong></p></td>
<td><p>Creates the desired filter. Overwrites existing if present.</p></td>
</tr>
<tr class="row-even"><td><p><strong>Update()</strong></p></td>
<td><p>update filters (e.g. call after upstream Modified)</p></td>
</tr>
<tr class="row-odd"><td><p><strong>GetOutputPort()</strong></p></td>
<td><p>Returns the output port</p></td>
</tr>
<tr class="row-even"><td><p><strong>GetOutput()</strong></p></td>
<td><p>Returns the output as a PolyData</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="pydar.ClassFilter.CreateFilter">
<span class="sig-name descname"><span class="pre">CreateFilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ClassFilter.CreateFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create desired filter replaces existing if one exists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>class_list</strong><span class="classifier">list, optional</span></dt><dd><p>List of categories to include in the output. If ‘all’ then we will
do no filtering. The default is [0, 1, 2, 70].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ClassFilter.GetOutput">
<span class="sig-name descname"><span class="pre">GetOutput</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ClassFilter.GetOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns polydata</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>vtkPolyData</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ClassFilter.GetOutputPort">
<span class="sig-name descname"><span class="pre">GetOutputPort</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ClassFilter.GetOutputPort" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns output port.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>vtkAlgorithmOutput</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ClassFilter.Update">
<span class="sig-name descname"><span class="pre">Update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ClassFilter.Update" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates pipeline</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydar.Classifier">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">Classifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">df_labeled=Empty</span> <span class="pre">DataFrame</span> <span class="pre">Columns:</span> <span class="pre">[]</span> <span class="pre">Index:</span> <span class="pre">[]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Classifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Manage multiple scans from the same area.</p>
<p>…</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df_labeled</strong><span class="classifier">pandas dataframe</span></dt><dd><p>A dataframe where each row is a classified point. Must contain column
‘Classification’.</p>
</dd>
<dt><strong>classifier</strong><span class="classifier">object</span></dt><dd><p>A classifier, initially probably 
sklearn.ensemble.RandomForestClassifer</p>
</dd>
<dt><strong>feature_list</strong><span class="classifier">list</span></dt><dd><p>List of features used to train classifier. Need to save for prediction
step.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>init_randomforest(n_jobs, **kwargs)</strong></p></td>
<td><p>Creates random forest classifier</p></td>
</tr>
<tr class="row-even"><td><p><strong>train_classifier()</strong></p></td>
<td><p>Trains classifier, does some decimation of ground category.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>classify_pdata()</strong></p></td>
<td><p>Updates Classification field in pdata.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="pydar.Classifier.classify_pdata">
<span class="sig-name descname"><span class="pre">classify_pdata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pdata</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Classifier.classify_pdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply classifier to classify points in the pdata. Pdata’s PointData
must contain all fields in feature_list</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pdata</strong><span class="classifier">vtkPolyData</span></dt><dd><p>vtkPolyData object to classify points in.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Classifier.init_histgradboost">
<span class="sig-name descname"><span class="pre">init_histgradboost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Classifier.init_histgradboost" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a HistGradientBoostingClassifier</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>**kwargs</strong><span class="classifier">dict</span></dt><dd><p>Additional keyword arguments to HistGradientBoostingClassifer</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Classifier.init_randomforest">
<span class="sig-name descname"><span class="pre">init_randomforest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Classifier.init_randomforest" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a RandomForestClassifer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n_jobs</strong><span class="classifier">int, optional</span></dt><dd><p>Number of . The default is -1.</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">dict</span></dt><dd><p>Additional keyword arguments to RandomForestClassifier.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Classifier.train_classifier">
<span class="sig-name descname"><span class="pre">train_classifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">feature_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_ground_multiplier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strat_by_class</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_ground</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Classifier.train_classifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Train classifier, kwargs go to train_test_split</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>feature_list</strong><span class="classifier">list</span></dt><dd><p>List of feature names to use as independent variables. Must be
columns in df_labeled.</p>
</dd>
<dt><strong>n_ground_multiplier</strong><span class="classifier">float</span></dt><dd><p>We have many more labeled ground points than others. So that
training doesn’t take forever we only take n times as many ground
points as all other classes combined. The default is 3.</p>
</dd>
<dt><strong>strat_by_class</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to stratify the split by ‘Classification’. The 
default is True.</p>
</dd>
<dt><strong>reduce_ground</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to reduce the number of ground points, the default
True.</p>
</dd>
<dt><strong>surface_only</strong><span class="classifier">bool, optional</span></dt><dd><p>If true just perform binary classification into snow surface
or not (lump roads and ground together). The default is False.</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">dict</span></dt><dd><p>Additional kwargs for train_test_split.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydar.Project">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">Project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'.1_.1_.01'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">import_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">load_scans</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">read_scans</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">import_las</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">create_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">las_fieldnames</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">70]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class linking relevant data for a project and methods for registration.</p>
<p>…</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>project_date</strong><span class="classifier">str</span></dt><dd><p>Date that this project was started on (1st day for 2 day scans)</p>
</dd>
<dt><strong>project_name</strong><span class="classifier">str</span></dt><dd><p>Filename of the RiSCAN project the tiepointlist comes from</p>
</dd>
<dt><strong>project_path</strong><span class="classifier">str</span></dt><dd><p>Directory location of the project.</p>
</dd>
<dt><strong>tiepointlist</strong><span class="classifier">TiePointList</span></dt><dd><p>Object containing tiepoints and methods for referencing them together.</p>
</dd>
<dt><strong>scan_dict</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of SingleScan objects keyed on scan names</p>
</dd>
<dt><strong>current_transform_list</strong><span class="classifier">list</span></dt><dd><p>The list of transforms currently applied to the project.</p>
</dd>
<dt><strong>filterName</strong><span class="classifier">str</span></dt><dd><p>Name of filter currently applied to all scans in project.</p>
</dd>
<dt><strong>mesh</strong><span class="classifier">vtkPolyData</span></dt><dd><p>Polydata containing a mesh representation of the project.</p>
</dd>
<dt><strong>image</strong><span class="classifier">vtkImageData</span></dt><dd><p>Image data containing gridded height information over specified region</p>
</dd>
<dt><strong>imageTransform</strong><span class="classifier">vtkTransform</span></dt><dd><p>Transform for going from mesh reference frame to image ref
frame. Needed because vtkImageData can only be axis aligned.</p>
</dd>
<dt><strong>dsa_image</strong><span class="classifier">datasetadapter</span></dt><dd><p>Wrapper to interact with image via numpy</p>
</dd>
<dt><strong>profile_dict</strong><span class="classifier">dict</span></dt><dd><p>Dictionary holding polydata for each profile that we create in the
project. Each entry is a Polydata whose points are a profile and the
PointData optionally includes upper and lower confidence intervals
Various functions can either access these profile data or display
it. Each polydata has a single polyline as its cell.</p>
</dd>
<dt><strong>empirical_cdf</strong><span class="classifier">tuple</span></dt><dd><p>(bounds, x, cdf) tuple with distribution of snow surface heights for 
use with transforming and normalizing z-values.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">1D array or list</span></dt><dd><p>Theta parameters for the GMRF used in pixel infilling. See Rue and
Held 2005 Chapter 5.1</p>
</dd>
<dt><strong>theta1</strong><span class="classifier">float</span></dt><dd><p>Scaling parameter for GMRF used in pixel infilling. See Rue and Held
2005 Chapter 5.1</p>
</dd>
<dt><strong>mu_agivenb</strong><span class="classifier">1D array</span></dt><dd><p>Expectation of missing pixel values conditioned on observed pixels.</p>
</dd>
<dt><strong>sparse_LAA</strong><span class="classifier">sparse matrix</span></dt><dd><p>Lower triangular Cholesky factor of the conditional precision matrix
(QAA) of the missing pixels conditioned on the observed pixels.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>add_z_offset(z_offset)</strong></p></td>
<td><p>Add z offset to all scans in project.</p></td>
</tr>
<tr class="row-even"><td><p><strong>apply_transforms(transform_list)</strong></p></td>
<td><p>Update transform for each scan and update current_transform_list.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>display_project(z_min, z_max, lower_threshold=-1000, upper_threshold=1000)</strong></p></td>
<td><p>Display project in a vtk interactive window.</p></td>
</tr>
<tr class="row-even"><td><p><strong>display_image(z_min, z_max)</strong></p></td>
<td><p>Display project image in a vtk interactive window.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>write_merged_points(output_name=self.project_name + ‘_merged.vtp’)</strong></p></td>
<td><p>Merge all transformed and filtered pointclouds and write to file.</p></td>
</tr>
<tr class="row-even"><td><p><strong>write_las_pdal(output_dir, filename)</strong></p></td>
<td><p>Merge all points and write to a las formatted output.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>write_mesh(output_name=self.project_name + ‘_mesh.vtp’)</strong></p></td>
<td><p>Write mesh to vtp file.</p></td>
</tr>
<tr class="row-even"><td><p><strong>read_mesh(mesh_name=self.project_name + ‘_mesh.vtp’)</strong></p></td>
<td><p>Read mesh from file.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>write_scans()</strong></p></td>
<td><p>Write all singlescans to files.</p></td>
</tr>
<tr class="row-even"><td><p><strong>read_scans()</strong></p></td>
<td><p>Read all singlescans from files.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>merged_points_to_mesh(subgrid_x, subgrid_y, min_pts=100, alpha=0,</strong></p></td>
<td><p>overlap=0.1) Merge all transformed pointclouds and convert to mesh.</p></td>
</tr>
<tr class="row-even"><td><p><strong>project_to_image(z_min, z_max, focal_point, camera_position,</strong></p></td>
<td><p>image_scale=500, lower_threshold=-1000, upper_threshold=1000, mode=’map’, colorbar=True, name=’’) Write out an image of the project (in point cloud) to the snapshot folder.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>add_transforms(key, matrix)</strong></p></td>
<td><p>Add the provided transform to each SingleScan</p></td>
</tr>
<tr class="row-even"><td><p><strong>create_normals(radius=2, max_nn=30)</strong></p></td>
<td><p>Estimate point normals (using Open3D).</p></td>
</tr>
<tr class="row-odd"><td><p><strong>create_z_sigma()</strong></p></td>
<td><p>For the current value of the transformation, project the pointwise uncertainty spheroids onto the z-axis and save in PointData.</p></td>
</tr>
<tr class="row-even"><td><p><strong>apply_manual_filter()</strong></p></td>
<td><p>Manually classify points within a selection loop.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>apply_snowflake_filter(shells)</strong></p></td>
<td><p>Apply the snowflake filter.</p></td>
</tr>
<tr class="row-even"><td><p><strong>apply_snowflake_filter_2(z_diff, N, r_min)</strong></p></td>
<td><p>Apply a snowflake filter based on z difference with nearby points.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>apply_snowflake_filter_returnindex(cylinder_rad, radial_precision)</strong></p></td>
<td><p>Filter snowflakes based on their return index and whether they are on the border of the visible region.</p></td>
</tr>
<tr class="row-even"><td><p><strong>create_scanwise_closest_point()</strong></p></td>
<td><p>For each point in each scan, find the vertical and horizontal distances to the closest point in all other scans. Useful for filtering out snowmobiles and humans and things that move.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>create_heightaboveground_pdal(resolution=1, voxel=true, h_voxel=0.1,</strong></p></td>
<td><p>v_voxel=0.1, project_dem=True) Create height above ground value for each point in scan.</p></td>
</tr>
<tr class="row-even"><td><p><strong>update_man_class_fields(update_fields=’all’, update_trans=True)</strong></p></td>
<td><p>Update the man_class table with values from the fields currently in polydata_raw. Useful, for example if we’ve improved the HAG filter and don’t want to have to repick all points.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>get_merged_points()</strong></p></td>
<td><p>Get the merged points as a polydata</p></td>
</tr>
<tr class="row-even"><td><p><strong>mesh_to_image(z_min, z_max, nx, ny, dx, dy, x0, y0)</strong></p></td>
<td><p>Interpolate mesh into image.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>merged_points_to_image(x0, y0, nx, ny, dx, dy, yaw, max_pts_bucket,</strong></p></td>
<td><p>lengthscale, outputscale) Convert a rectangular area of points to an image using gpytorch.</p></td>
</tr>
<tr class="row-even"><td><p><strong>plot_image(z_min, z_max, cmap=’inferno’)</strong></p></td>
<td><p>Plots the image using matplotlib</p></td>
</tr>
<tr class="row-odd"><td><p><strong>get_np_nan_image()</strong></p></td>
<td><p>Convenience function for copying the image to a numpy object.</p></td>
</tr>
<tr class="row-even"><td><p><strong>create_empirical_cdf(bounds)</strong></p></td>
<td><p>Creates an empirical cdf from z-values of all points within bounds.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>create_empirical_cdf_image(z_min, z_max)</strong></p></td>
<td><p>Creates an empirical cdf from z-values of image.</p></td>
</tr>
<tr class="row-even"><td><p><strong>set_empirical_cdf(x, cdf, bounds)</strong></p></td>
<td><p>Set the empirical cdf</p></td>
</tr>
<tr class="row-odd"><td><p><strong>create_normalized_heights()</strong></p></td>
<td><p>Create the normalized heights, assumes that empirical cdf exists.</p></td>
</tr>
<tr class="row-even"><td><p><strong>create_im_gaus()</strong></p></td>
<td><p>Create normalized image based on the empirical cdf</p></td>
</tr>
<tr class="row-odd"><td><p><strong>add_theta(theta1, theta)</strong></p></td>
<td><p>Adds the GMRF parameters theta1 and theta to attributes.</p></td>
</tr>
<tr class="row-even"><td><p><strong>create_im_nan_border(buffer)</strong></p></td>
<td><p>Creates a mask for which missing pixels not to infill.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>write_image(output_name=None)</strong></p></td>
<td><p>Write vtkImageData to file. Useful for saving im_nan_border.</p></td>
</tr>
<tr class="row-even"><td><p><strong>read_image(image_path=None)</strong></p></td>
<td><p>Read image from file.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>create_gmrf()</strong></p></td>
<td><p>Create GMRF for pixel infilling. Generates mu_agivenb and sparse_LAA.</p></td>
</tr>
<tr class="row-even"><td><p><strong>create_reflectance()</strong></p></td>
<td><p>Create reflectance for each scan.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>correct_reflectance_radial()</strong></p></td>
<td><p>Attempt to correct for reflectance bias due to distance from scanner.</p></td>
</tr>
<tr class="row-even"><td><p><strong>areapoints_to_cornercoords(areapoints)</strong></p></td>
<td><p>Given a set of points, identified by their scan names and point ids, return the coordinates of those points in the current reference frame.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.add_theta">
<span class="sig-name descname"><span class="pre">add_theta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.add_theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds theta attributes for specifying GMRF, see Rue and Held 2005 ch. 5</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta1</strong><span class="classifier">float</span></dt><dd><p>Scaling parameter theta1.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">array</span></dt><dd><p>Conditional covariances of neighbors, see Rue and Held Ch. 5.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.add_transform">
<span class="sig-name descname"><span class="pre">add_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">history_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.add_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the provided transform to each single scan</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>key</strong><span class="classifier">const (could be string or tuple)</span></dt><dd><p>Dictionary key for the transforms dictionary.</p>
</dd>
<dt><strong>matrix</strong><span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
<dt><strong>history_dict</strong><span class="classifier">dict</span></dt><dd><p>dict tree containing history of transform. If None then we create
a Transform Source node with the matrix as a param. The default
is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.add_transform_from_tiepointlist">
<span class="sig-name descname"><span class="pre">add_transform_from_tiepointlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.add_transform_from_tiepointlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the transform in the tiepointlist to each single scan.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>key</strong><span class="classifier">const (could be string or tuple)</span></dt><dd><p>Dictionary key for the transforms dictionary.</p>
</dd>
<dt><strong>matrix</strong><span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.add_z_offset">
<span class="sig-name descname"><span class="pre">add_z_offset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z_offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">history_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.add_z_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Add z_offset transform to each single scan in scan_dict</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z_offset</strong><span class="classifier">float.</span></dt><dd><p>z offset to add in meters.</p>
</dd>
<dt><strong>history_dict</strong><span class="classifier">dict</span></dt><dd><p>dict tree containing history of transform. The default
is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.apply_man_class">
<span class="sig-name descname"><span class="pre">apply_man_class</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.apply_man_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Update all point Classifications with their values in man_class</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.apply_manual_filter">
<span class="sig-name descname"><span class="pre">apply_manual_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">corner_coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.0,</span> <span class="pre">0.0,</span> <span class="pre">1.0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">category</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">73</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'currentFilter'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.apply_manual_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Manually classify points using a selection loop.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>corner_coords</strong><span class="classifier">ndarray</span></dt><dd><p>Nx3 array of points defining corners of selection.</p>
</dd>
<dt><strong>normal</strong><span class="classifier">array-like, optional</span></dt><dd><p>Three element vector describing normal (axis) of loop. 
The default is (0, 0, 1).</p>
</dd>
<dt><strong>category</strong><span class="classifier">uint8, optional</span></dt><dd><p>Which category to classify points as. The default is 73.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>What to apply filter to. Options are ‘currentFilter’ and
‘transformFilter’. The default is ‘currentFilter’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.apply_snowflake_filter">
<span class="sig-name descname"><span class="pre">apply_snowflake_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shells</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.apply_snowflake_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a snowflake filter to each SingleScan</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shells</strong><span class="classifier">array-like of tuples</span></dt><dd><p>shells is an array-like set of tuples where each tuple is four
elements long (inner_r, outer_r, point_radius, neighbors). <a href="#id3"><span class="problematic" id="id4">*</span></a>_r
define the inner and outer radius of a halo defining shell. 
point_radius is radius for vtkRadiusOutlierRemoval to look at
(if 0, remove all points). Neighbors is number of neighbors that
must be within point_radius (if 0, keep all points)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.apply_snowflake_filter_2">
<span class="sig-name descname"><span class="pre">apply_snowflake_filter_2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z_diff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_min</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.apply_snowflake_filter_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter snowflakes based on their vertical distance from nearby points.</p>
<p>Here we exploit the fact that snowflakes (and for that matter power
cables and some other human objects) are higher than their nearby
points. The filter steps through each point in the transformed
dataset and compares it’s z value with the mean of the z-values of
the N closest points. If the difference exceeds z_diff then set the
Classification for that point to be 2. Also, there is a shadow around the
base of the scanner so all points within there must be spurious. We
filter all points within r_min</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z_diff</strong><span class="classifier">float</span></dt><dd><p>Maximum vertical difference in m a point can have from its 
neighborhood.</p>
</dd>
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of neighbors to find.</p>
</dd>
<dt><strong>r_min</strong><span class="classifier">float</span></dt><dd><p>Radius of scanner in m within which to filter all points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.apply_snowflake_filter_returnindex">
<span class="sig-name descname"><span class="pre">apply_snowflake_filter_returnindex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cylinder_rad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0006170670747442177</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radial_precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.apply_snowflake_filter_returnindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter snowflakes using return index visible space.</p>
<p>Snowflakes are too small to fully occlude the laser pulse. Therefore
all snowflakes will be one of multiple returns (returnindex&lt;-1).
However, the edges of shadows will also be one of multiple returns. To
address this we look at each early return and check if it’s on the 
border of the visible area from the scanner’s perspective. We do this
by finding all points within cylinder_rad of the point in question
in panorama space. Then, if the radial value of the point in question
is greater than any of these radial values that means the point
in question is on the border of the visible region and we should keep
it.</p>
<p>All points that this filter identifies as snowflakes are set to
Classification=65</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cylinder_rad</strong><span class="classifier">float, optional</span></dt><dd><p>The radius of a cylinder, in radians around an early return
to look for last returns. The default is 0.025*np.sqrt(2)*np.pi/
180.</p>
</dd>
<dt><strong>radial_precision</strong><span class="classifier">float, optional</span></dt><dd><p>If an early return’s radius is within radial_precision of an
adjacent last return accept it as surface. The default is 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.apply_transforms">
<span class="sig-name descname"><span class="pre">apply_transforms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transform_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.apply_transforms" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply transforms in transform list to each SingleScan</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>transform_list</strong><span class="classifier">list</span></dt><dd><p>str in list must be transforms in each SingleScan, see SingleScan 
class for more details.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.areapoints_to_cornercoords">
<span class="sig-name descname"><span class="pre">areapoints_to_cornercoords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">areapoints</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.areapoints_to_cornercoords" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a set of areapoints given as scan_name, PointId pairs. Returns
the coordinates of these points in the current reference frame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>areapoints</strong><span class="classifier">List of lists or tuples</span></dt><dd><p>List of area points in the desired order. Each point is a tuple
in which the zeroth element is the scan_name and the first
element is the PointId</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray.</dt><dd><p>Nx3 array where N is the number of points.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.correct_reflectance_radial">
<span class="sig-name descname"><span class="pre">correct_reflectance_radial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.correct_reflectance_radial" title="Permalink to this definition">¶</a></dt>
<dd><p>Corrects radial artifact in reflectance. result: ‘reflectance_radial’</p>
<p>Attempts to correct radial artifact in reflectance. Still developing
the best way to do this.</p>
<p>If mode is ‘median’: bin the raw reflectances by radial distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mode</strong><span class="classifier">str</span></dt><dd><p>Method for correcting radial artifact in reflectances. Currently
only coded for ‘median’.</p>
</dd>
<dt><strong>r_min</strong><span class="classifier">float, optional</span></dt><dd><p>Needed for method ‘median’ minimum radius to bin</p>
</dd>
<dt><strong>r_max</strong><span class="classifier">float, optional</span></dt><dd><p>Needed for method ‘median’ maximum radius to bin</p>
</dd>
<dt><strong>num</strong><span class="classifier">int, optional</span></dt><dd><p>Needed for method ‘median’, number of bins</p>
</dd>
<dt><strong>base</strong><span class="classifier">float, optional</span></dt><dd><p>Needed for method ‘median’, base for logspaced bins</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.create_elevation_mean_fill">
<span class="sig-name descname"><span class="pre">create_elevation_mean_fill</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.create_elevation_mean_fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill missing pixels in Elevation with transformed expectation</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.create_empirical_cdf">
<span class="sig-name descname"><span class="pre">create_empirical_cdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.create_empirical_cdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an empirical distribution of heights from histogram.</p>
<p>Currently sets the resolution of distribution to 1 mm vertically but
could change that if needed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bounds</strong><span class="classifier">six element tuple, optional</span></dt><dd><p>The boundaries of box of points to create distribution from.
Format is (xmin, xmax, ymin, ymax, zmin, zmax). If None use all
points. The default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.create_empirical_cdf_image">
<span class="sig-name descname"><span class="pre">create_empirical_cdf_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_max</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.create_empirical_cdf_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an empirical distribution of heights from the image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z_min</strong><span class="classifier">float</span></dt><dd><p>Minimum height value to consider.</p>
</dd>
<dt><strong>z_max</strong><span class="classifier">float</span></dt><dd><p>Maximum height value to consider.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.create_gmrf">
<span class="sig-name descname"><span class="pre">create_gmrf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.create_gmrf" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a GMRF for the missing data in im_gaus using theta1 and theta.</p>
<p>This method implements our pixel infilling scheme, which is:
represent the gaussian transformed image as a Gaussian Markov Random
Field with a known, sparse precision matrix Q. The neighbors of each
node are the points in a square around it (usually 5 pixels wide). If
the whole image is a GMRF, then any subset A is also a GMRF with a 
mean function that is conditional on the points not in the subset (
we’ll label these points B) and the precision matrix of A (QAA) is
just a subset of Q. Specifically, we choose the missing pixels to be
the subset A and the known ones to be our subset B. Then, following
Rue and Held 2005 ch. 2 we can find the expectation of this GMRF and
simulate draws from it.</p>
<p>This function generates the attributes mu_agivenb and sparse_LAA</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.create_heightaboveground_pdal">
<span class="sig-name descname"><span class="pre">create_heightaboveground_pdal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_dem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.create_heightaboveground_pdal" title="Permalink to this definition">¶</a></dt>
<dd><p>Create height above ground for each point in each scan.</p>
<p>For now we are just building a dem from inverse distance weighting
of all points. Will change to csf filter eventually.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>project_dem</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to create a dem from all scans in the project. 
The default is True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.create_im_gaus">
<span class="sig-name descname"><span class="pre">create_im_gaus</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.create_im_gaus" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform image to gaussian using current value of empirical cdf</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.create_im_gaus_mean_fill">
<span class="sig-name descname"><span class="pre">create_im_gaus_mean_fill</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.create_im_gaus_mean_fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill missing pixels in im_gaus with expectation (mu_agivenb)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.create_im_nan_border">
<span class="sig-name descname"><span class="pre">create_im_nan_border</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.create_im_nan_border" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a mask of which missing pixels not to infill.</p>
<p>We don’t want to infill certain pixels because either, they border the 
boundary of our domain or more generally are conditionally dependent
on a pixel outside the border of our domain (which we cannot know).
We create this mask recursively starting at the boundary of the domain
and then iteratively finding all missing pixels that are in contact
with the boundary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>buffer</strong><span class="classifier">int, optional</span></dt><dd><p>The width of the neighborhood around a pixel, same as m in the
specification of theta. The default is 2.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.create_normalized_heights">
<span class="sig-name descname"><span class="pre">create_normalized_heights</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.create_normalized_heights" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the empirical cdf to each single scan to create normalized height</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.create_normals">
<span class="sig-name descname"><span class="pre">create_normals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.create_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Open3d to compute pointwise normals and store.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">float, optional</span></dt><dd><p>Max distance to look for nearby points. The default is 2.</p>
</dd>
<dt><strong>max_nn</strong><span class="classifier">int, optional</span></dt><dd><p>max number of points to use in normal estimation. 
The default is 30.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.create_reflectance">
<span class="sig-name descname"><span class="pre">create_reflectance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.create_reflectance" title="Permalink to this definition">¶</a></dt>
<dd><p>Create reflectance fielf for each scan.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.create_scanwise_closest_point">
<span class="sig-name descname"><span class="pre">create_scanwise_closest_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.create_scanwise_closest_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Create VerticalClosestPoint and HorizontalClosestPoint fields.</p>
<p>For each point in each scan, find the vertical and horizontal
distances to the closest point in all other scans. Useful for
filtering out snowmobiles and humans and things that move.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.create_z_sigma">
<span class="sig-name descname"><span class="pre">create_z_sigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma_ro</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.008</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_bw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">7.5e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.create_z_sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the pointwise uncertainty in the z-direction.</p>
<p>For each point, project the pointwise uncertainty spheroid onto the z 
unit vector in the reference frame defined by the current transform.</p>
<p>Each point measured by the scanner has a positional uncertainty that
can be described as a gaussian spheroid. The symmetry axis of this
spheroid is aligned with the direction of the laser beam, which we
will name p_hat. Along p_hat the uncertainty is determined by the
ranging uncertainty of the laser (sigma_ro). Perpendicular to p_hat
in all directions, our uncertainty is due to the bandwidth spreading
of the laser beam–sigma_bw. sigma_bw is measured in radians and to 
get sigma_b measured in m we need to multiply by the distance.</p>
<p>In order to find the uncertainty in the z direction of the current
transform, we first project the z unit vector in the current 
transform’s reference frame into the scanner’s reference 
frame–z_prime. Then we use the dot product of z_prime with p_hat for
each point to get the cosine of the angle between them. Finally,
the distance from the origin of the uncertainty spheroid to the 1
sigma surface along the direction z_prime can be computed from the
squared cosine of the angle between z_prime and p_hat.</p>
<p>Finally, we save the result as an array in polydata_raw.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sigma_ro</strong><span class="classifier">float, optional</span></dt><dd><p>The standard deviation of the laser’s ranging uncertainty in m.
The default is 0.008 (value for VZ-1000)</p>
</dd>
<dt><strong>sigma_bw</strong><span class="classifier">float, optional</span></dt><dd><p>The standard deviation of the laser’s bandwidth spreading in
radians. The defaults is 0.0003/4 (value for VZ-1000)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.display_image">
<span class="sig-name descname"><span class="pre">display_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Elevation'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warp_scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_scanners</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scanner_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Gray'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scanner_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">150</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.display_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Display image in vtk interactive window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z_min</strong><span class="classifier">float</span></dt><dd><p>Minimum z value in m for color.</p>
</dd>
<dt><strong>z_max</strong><span class="classifier">float</span></dt><dd><p>Maximum z value in m for color.</p>
</dd>
<dt><strong>field</strong><span class="classifier">str, optional</span></dt><dd><p>Which field in PointData to display. The default is ‘Elevation’</p>
</dd>
<dt><strong>warp_scalars</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to warp the scalars in the image to create 3D surface</p>
</dd>
<dt><strong>color_field</strong><span class="classifier">str, optional</span></dt><dd><p>If we want to display the color for a different field overlain
on the geometry from warp scalars use this option. The defaut
is None.</p>
</dd>
<dt><strong>show_points</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to also render the points. The default is False.</p>
</dd>
<dt><strong>profile_list</strong><span class="classifier">list, optional</span></dt><dd><p>List of keys of profiles in the profiles dict to display. The 
default is [].</p>
</dd>
<dt><strong>show_scanners</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to show the scanners. The default is False.</p>
</dd>
<dt><strong>scanner_color</strong><span class="classifier">str, optional</span></dt><dd><p>Name of the color to display as. The default is ‘Gray’</p>
</dd>
<dt><strong>scanner_length</strong><span class="classifier">float, optional</span></dt><dd><p>Length of the ray indicating the scanner’s start orientation in m.
The default is 150</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.display_project">
<span class="sig-name descname"><span class="pre">display_project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Elevation'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapview</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_scanners</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scanner_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Gray'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scanner_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">150</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.display_project" title="Permalink to this definition">¶</a></dt>
<dd><p>Display all scans in a vtk interactive window.</p>
<p>Points will be colored by elevation, apply_transforms must be run 
before this the transform data into desired reference frame.</p>
<p>Currently, this renderwindowinteractor is set to write the camera
position and focal point to std out when the user presses ‘u’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z_min</strong><span class="classifier">float</span></dt><dd><p>Lower cutoff for plotting colors.</p>
</dd>
<dt><strong>z_max</strong><span class="classifier">float</span></dt><dd><p>Upper cutoff for plotting colors.</p>
</dd>
<dt><strong>lower_threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Minimum elevation of point to display. The default is -1000.</p>
</dd>
<dt><strong>upper_threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Maximum elevation of point to display. The default is 1000.</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool, optional</span></dt><dd><p>Display colorbar. The default is True.</p>
</dd>
<dt><strong>field</strong><span class="classifier">str, optional</span></dt><dd><p>Which scalar field to display (elevation, reflectance, etc). The
default is ‘Elevation’</p>
</dd>
<dt><strong>mapview</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to use a parallel projection. The default is False.</p>
</dd>
<dt><strong>profile_list</strong><span class="classifier">list, optional</span></dt><dd><p>Which, if any, profiles to display along with the rendering. This
list is composed of lists whose zeroth element is always the
key of the profile in self.profile_dict. Element 1 is line width
in pixels (optional) Elements 2, 3, 4, are color
channels (optional) and element 5 is opacity (optional). The default
is [].</p>
</dd>
<dt><strong>show_scanners</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to show the scanners. The default is False.</p>
</dd>
<dt><strong>scanner_color</strong><span class="classifier">str, optional</span></dt><dd><p>Name of the color to display as. The default is ‘Gray’</p>
</dd>
<dt><strong>scanner_length</strong><span class="classifier">float, optional</span></dt><dd><p>Length of the ray indicating the scanner’s start orientation in m.
The default is 150</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.dummy_im_nan_border">
<span class="sig-name descname"><span class="pre">dummy_im_nan_border</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.dummy_im_nan_border" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an all false im_nan_border.</p>
<p>In case we want to do pixel infilling on all pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.get_image">
<span class="sig-name descname"><span class="pre">get_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Elevation'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warp_scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">9999.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nan_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.get_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Return image as vtkImageData or vtkPolyData depending on warp_scalars</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>field</strong><span class="classifier">str, optional</span></dt><dd><p>Which field in PointData to set active. The default is ‘Elevation’</p>
</dd>
<dt><strong>warp_scalars</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to warp the scalars in the image to create 3D surface</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>image: vtkImageData or vtkPolyData</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.get_merged_points">
<span class="sig-name descname"><span class="pre">get_merged_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">history_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yaw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.get_merged_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a polydata with merged points from all single scans</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>port</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to return an output connection instead of a polydata.
The default is False</p>
</dd>
<dt><strong>history_dict</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to return the history dict. Note that if port is False,
we return a deep copy of the history dict that is not linked to
the SingleScans whereas if port is true we return a linked 
version. The default is False.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">float, optional</span></dt><dd><p>x coordinate of the selection box. The default is None</p>
</dd>
<dt><strong>y0</strong><span class="classifier">float, optional</span></dt><dd><p>y coordinate of the selection box. The default is None</p>
</dd>
<dt><strong>wx</strong><span class="classifier">float, optional</span></dt><dd><p>the selection box width. The default is None</p>
</dd>
<dt><strong>wy</strong><span class="classifier">float, optional</span></dt><dd><p>the selection box height. The default is None</p>
</dd>
<dt><strong>yaw</strong><span class="classifier">float, optional</span></dt><dd><p>yaw of the selection box. The default is 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>vtkPolyData.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.get_np_nan_image">
<span class="sig-name descname"><span class="pre">get_np_nan_image</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.get_np_nan_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for copying the image to a numpy object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nan_image</strong><span class="classifier">numpy ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.get_profile">
<span class="sig-name descname"><span class="pre">get_profile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.get_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the requested profile as a numpy array</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.image_transect">
<span class="sig-name descname"><span class="pre">image_transect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.image_transect" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample a transect through the current image and save in profiles.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.load_man_class">
<span class="sig-name descname"><span class="pre">load_man_class</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.load_man_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct each single scan to load it’s man_class table</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.merged_points_to_image">
<span class="sig-name descname"><span class="pre">merged_points_to_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ny</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lengthscale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outputscale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yaw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_pts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_pts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">my</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">corner_coords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_dist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim_param</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multiply_outputscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.merged_points_to_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a rectangular area of points to an image using gpytorch.</p>
<p>Take a rectangular area, create an array of gridded coordinates where
we want to evaluate surface (grid_points). For each grid_point, find
the n_neighbors nearest neighbors in the lidar point cloud. Group
grid_points into squarish groups of mx x my grid_points. For each of
these M groups pool the nearest neighbors. Now we have groups of
at most mx x my x n_neighbors lidar points with which to estimate the
surface height and mx x my grid_points. For each M group, run 
gaussian process regression to estimate the surface height at the grid
points. Combine all grid points together into one image and save the
result in the self.image attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nx</strong><span class="classifier">int</span></dt><dd><p>Number of gridcells in x direction.</p>
</dd>
<dt><strong>ny</strong><span class="classifier">int</span></dt><dd><p>Number of gridcells in y direction.</p>
</dd>
<dt><strong>dx</strong><span class="classifier">float</span></dt><dd><p>Width of gridcells in x direction.</p>
</dd>
<dt><strong>dy</strong><span class="classifier">float</span></dt><dd><p>Width of gridcells in y direction.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">float</span></dt><dd><p>x coordinate of the origin in m.</p>
</dd>
<dt><strong>y0</strong><span class="classifier">float</span></dt><dd><p>y coordinate of the origin in m.</p>
</dd>
<dt><strong>yaw</strong><span class="classifier">float, optional</span></dt><dd><p>yaw angle in degrees of image to create, for generating 
non-axis aligned image. The default is 0.</p>
</dd>
<dt><strong>lengthscale</strong><span class="classifier">float</span></dt><dd><p>Length scale for the matern kernel in m. 2 seems reasonable.</p>
</dd>
<dt><strong>outputscale</strong><span class="classifier">float</span></dt><dd><p>Outputscale for the scale kernel. Around 0.01 seems reasonable.</p>
</dd>
<dt><strong>nu</strong><span class="classifier">float</span></dt><dd><p>Nu for the Matern kernel, must be one of 0.5, 1.5, or 2.5</p>
</dd>
<dt><strong>n_neighbors</strong><span class="classifier">int, optional</span></dt><dd><p>Number of neighbors around each grid point. The default is 50.</p>
</dd>
<dt><strong>max_pts</strong><span class="classifier">int, optional</span></dt><dd><p>If a chunk has more points than max_pts, then reduce n_neighbors by
10% until we’re within max_pts.</p>
</dd>
<dt><strong>min_pts</strong><span class="classifier">int, optional</span></dt><dd><p>If a chunk has fewer points than min_pts, increase n_neighbors by
10% until we’re greater than min_pts.</p>
</dd>
<dt><strong>mx</strong><span class="classifier">int, optional</span></dt><dd><p>Number of grid points in the x direction to group together in M
groups. The default is 32.</p>
</dd>
<dt><strong>my</strong><span class="classifier">int, optional</span></dt><dd><p>Number of grid points in the y direction to group together in M
groups. The default is 32.</p>
</dd>
<dt><strong>eps</strong><span class="classifier">float, optional</span></dt><dd><p>Eps for nearest neighbors search (see scipy.spatial.cKDTree) for
more details. The default is 0 (exact nearest neighbors)</p>
</dd>
<dt><strong>corner_coords</strong><span class="classifier">Nx3 array, optional</span></dt><dd><p>Corner coordinates of selection if we want to limit output</p>
</dd>
<dt><strong>optimize</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to search for optimal hyperparameters for the GP. The
default is False.</p>
</dd>
<dt><strong>learning_rate</strong><span class="classifier">float, optional</span></dt><dd><p>The learning rate if we are optimizing (currently just using ADAM). 
The default is 0.1.</p>
</dd>
<dt><strong>n_iter</strong><span class="classifier">int, optional</span></dt><dd><p>The number of iterations to run optimizer for. Note that we will 
only ever run optimizer for max_time. The default is None.</p>
</dd>
<dt><strong>max_time</strong><span class="classifier">float, optional</span></dt><dd><p>The maximum amount of time (in seconds) to run an optimization for. 
The default is 60.</p>
</dd>
<dt><strong>optim_param</strong><span class="classifier">list, optional</span></dt><dd><p>The parameters to optimize, as a list of dicts. If None, we will
optimize across all parameters. The default is None.</p>
</dd>
<dt><strong>multiply_outputscale</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, set outputscale for each chunk to be outputscale times
the variance of the z-values of points in that chunk. The default 
is False.</p>
</dd>
<dt><strong>var_radius</strong><span class="classifier">float, optional</span></dt><dd><p>If this is given and multiply_outputscale is True, instead of 
using the variance of the points in the chunk, we use the variance
of the z values of points within var_radius of the centroid of
the chunk. The default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.merged_points_to_mesh">
<span class="sig-name descname"><span class="pre">merged_points_to_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">13</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yaw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.merged_points_to_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Create mesh from all points in singlescans.</p>
<p>Using Poisson surface reconstruction from Kazhdan 2006 implemented in
Open3d. This function assumes that our points have normals!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>depth</strong><span class="classifier">int, optional</span></dt><dd><p>The depth into the octree for the surface reconstruction to go.
The default is 13.</p>
</dd>
<dt><strong>min_density</strong><span class="classifier">float, optional</span></dt><dd><p>We will filter out triangles that are based on fewer than this
number of points. The default is 9.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">float, optional</span></dt><dd><p>x coordinate of the selection box. The default is None</p>
</dd>
<dt><strong>y0</strong><span class="classifier">float, optional</span></dt><dd><p>y coordinate of the selection box. The default is None</p>
</dd>
<dt><strong>wx</strong><span class="classifier">float, optional</span></dt><dd><p>the selection box width. The default is None</p>
</dd>
<dt><strong>wy</strong><span class="classifier">float, optional</span></dt><dd><p>the selection box height. The default is None</p>
</dd>
<dt><strong>yaw</strong><span class="classifier">float, optional</span></dt><dd><p>yaw of the selection box. The default is 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.merged_points_transect_gp">
<span class="sig-name descname"><span class="pre">merged_points_transect_gp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_z_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lengthscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outputscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">60</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.merged_points_transect_gp" title="Permalink to this definition">¶</a></dt>
<dd><p>Use gpytorch to infer a surface transect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x0</strong><span class="classifier">float</span></dt><dd><p>Coordinate in project reference frame.</p>
</dd>
<dt><strong>y0</strong><span class="classifier">float</span></dt><dd><p>Coordinate in project reference frame.</p>
</dd>
<dt><strong>x1</strong><span class="classifier">float</span></dt><dd><p>Coordinate in project reference frame.</p>
</dd>
<dt><strong>y1</strong><span class="classifier">float</span></dt><dd><p>Coordinate in project reference frame.</p>
</dd>
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of points to put in transect.</p>
</dd>
<dt><strong>key</strong><span class="classifier">const (str, tuple, etc)</span></dt><dd><p>Key to store this profile in profile_dict under.</p>
</dd>
<dt><strong>mx</strong><span class="classifier">int, optional</span></dt><dd><p>Number of transect points to estimate in each chunk. The default
is 256.</p>
</dd>
<dt><strong>n_neighbors</strong><span class="classifier">int, optional</span></dt><dd><p>Number of neighbors around each transect point to use. The default
is 256</p>
</dd>
<dt><strong>eps</strong><span class="classifier">float, optional</span></dt><dd><p>Eps for nearest neighbors search (see scipy.spatial.cKDTree) for
more details. The default is 0 (exact nearest neighbors)</p>
</dd>
<dt><strong>use_z_sigma</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to use the computed pointwise uncertainties or not.
Generally you should have a reason for not using them. If False we
will just just a GaussianLikelihood for our likelihood. The default
is True.</p>
</dd>
<dt><strong>lengthscale</strong><span class="classifier">float, optional</span></dt><dd><p>Lengthscale for kernel in m. See run_gp. The default is None.</p>
</dd>
<dt><strong>outputscale</strong><span class="classifier">float, optional</span></dt><dd><p>Outputscale for kernel. See run_gp. The default is None.</p>
</dd>
<dt><strong>mean</strong><span class="classifier">float, optional</span></dt><dd><p>Initial constant mean value for the GP. If None it will be set to 
the mean of norm_height. The default is None.</p>
</dd>
<dt><strong>nu</strong><span class="classifier">float, optional</span></dt><dd><p>nu value of Matern kernel. It must be one of [0.5, 1.5, 2.5]. The
default is 0.5 (exponential kernel)</p>
</dd>
<dt><strong>optimize</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to search for optimal hyperparameters for the GP. The
default is False.</p>
</dd>
<dt><strong>learning_rate</strong><span class="classifier">float, optional</span></dt><dd><p>The learning rate if we are optimizing (currently just using ADAM). 
The default is 0.1.</p>
</dd>
<dt><strong>n_iter</strong><span class="classifier">int, optional</span></dt><dd><p>The number of iterations to run optimizer for. Note that we will 
only ever run optimizer for max_time. The default is None.</p>
</dd>
<dt><strong>max_time</strong><span class="classifier">float, optional</span></dt><dd><p>The maximum amount of time (in seconds) to run an optimization for. 
The default is 60.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.mesh_to_image">
<span class="sig-name descname"><span class="pre">mesh_to_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ny</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yaw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.mesh_to_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate mesh at regularly spaced points.</p>
<p>Currently this image can only be axis aligned, if you want a different
orientation then you need to apply the appropriate transformation to
the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nx</strong><span class="classifier">int</span></dt><dd><p>Number of gridcells in x direction.</p>
</dd>
<dt><strong>ny</strong><span class="classifier">int</span></dt><dd><p>Number of gridcells in y direction.</p>
</dd>
<dt><strong>dx</strong><span class="classifier">int</span></dt><dd><p>Width of gridcells in x direction.</p>
</dd>
<dt><strong>dy</strong><span class="classifier">int</span></dt><dd><p>Width of gridcells in y direction.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">float</span></dt><dd><p>x coordinate of the origin in m.</p>
</dd>
<dt><strong>y0</strong><span class="classifier">float</span></dt><dd><p>y coordinate of the origin in m.</p>
</dd>
<dt><strong>yaw</strong><span class="classifier">float, optional</span></dt><dd><p>yaw angle in degerees of image to create, for generating 
non-axis aligned image. The default is 0</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.mesh_transect">
<span class="sig-name descname"><span class="pre">mesh_transect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.mesh_transect" title="Permalink to this definition">¶</a></dt>
<dd><p>Cut a transect through the mesh, return the transect</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x0</strong><span class="classifier">float</span></dt><dd><p>Coordinate in project reference frame.</p>
</dd>
<dt><strong>y0</strong><span class="classifier">float</span></dt><dd><p>Coordinate in project reference frame.</p>
</dd>
<dt><strong>x1</strong><span class="classifier">float</span></dt><dd><p>Coordinate in project reference frame.</p>
</dd>
<dt><strong>y1</strong><span class="classifier">float</span></dt><dd><p>Coordinate in project reference frame.</p>
</dd>
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of points to put in transect.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>N x 4 array with x coord, y coord, length along transect and z</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.plot_image">
<span class="sig-name descname"><span class="pre">plot_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'inferno'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(15,</span> <span class="pre">15)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.plot_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the image of this project using matplotlib</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z_min</strong><span class="classifier">float</span></dt><dd><p>Minimum z value in m for color.</p>
</dd>
<dt><strong>z_max</strong><span class="classifier">float</span></dt><dd><p>Maximum z value in m for color.</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">str, optional</span></dt><dd><p>Name of matplotlib colormap to use. The default is ‘inferno’.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">tuple, optional</span></dt><dd><p>Figure size. The default is (15, 15)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f, ax</strong><span class="classifier">matplotlib figure and axes objects</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.point_to_grid_average_image">
<span class="sig-name descname"><span class="pre">point_to_grid_average_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ny</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yaw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.point_to_grid_average_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a rectangular area of points to an image by gridded averaging</p>
<p>Requires cython_util</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nx</strong><span class="classifier">int</span></dt><dd><p>Number of gridcells in x direction.</p>
</dd>
<dt><strong>ny</strong><span class="classifier">int</span></dt><dd><p>Number of gridcells in y direction.</p>
</dd>
<dt><strong>dx</strong><span class="classifier">float</span></dt><dd><p>Width of gridcells in x direction.</p>
</dd>
<dt><strong>dy</strong><span class="classifier">float</span></dt><dd><p>Width of gridcells in y direction.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">float</span></dt><dd><p>x coordinate of the origin in m.</p>
</dd>
<dt><strong>y0</strong><span class="classifier">float</span></dt><dd><p>y coordinate of the origin in m.</p>
</dd>
<dt><strong>yaw</strong><span class="classifier">float, optional</span></dt><dd><p>yaw angle in degrees of image to create, for generating 
non-axis aligned image. The default is 0.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.project_to_image">
<span class="sig-name descname"><span class="pre">project_to_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">focal_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camera_position</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roll</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Elevation'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(2000,</span> <span class="pre">1000)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.project_to_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Write an image of the project to the snapshots folder.</p>
<p>Assumes we want an orthorectified image (mode=’map’) and we want the
default image name to just be the project name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z_min</strong><span class="classifier">float</span></dt><dd><p>Minimum z value to display colors.</p>
</dd>
<dt><strong>z_max</strong><span class="classifier">float</span></dt><dd><p>Maximum z value to display colors.</p>
</dd>
<dt><strong>focal_point</strong><span class="classifier">3 element array like</span></dt><dd><p>Focal point of the camera in the project’s reference frame.</p>
</dd>
<dt><strong>camera_position</strong><span class="classifier">3 element array like</span></dt><dd><p>Camera position in the project’s reference frame.</p>
</dd>
<dt><strong>roll</strong><span class="classifier">float, optional</span></dt><dd><p>Camera roll in degrees. The default is 0.</p>
</dd>
<dt><strong>image_scale</strong><span class="classifier">float, optional</span></dt><dd><p>Image scale used in parallel projection. The default is 500.</p>
</dd>
<dt><strong>lower_threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Value of z to clip below. The default is -1000.</p>
</dd>
<dt><strong>upper_threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Value of z to clip above. The default is 1000.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>What kind of projection system to use. ‘map’ indicates parallel
or orthorectified projection. The default is None.</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to display a colorbar.</p>
</dd>
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>Name to append to this snapshot. The default is ‘’.</p>
</dd>
<dt><strong>window_size</strong><span class="classifier">tuple, optional</span></dt><dd><p>Window size in pixels. The default is (2000, 1000)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.read_image">
<span class="sig-name descname"><span class="pre">read_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mesh'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.read_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Read in the image from a file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image_path</strong><span class="classifier">str, optional</span></dt><dd><p>Path to the image, if none use the image directory. 
The default is None.</p>
</dd>
<dt><strong>suffix</strong><span class="classifier">str, optional</span></dt><dd><p>The suffix for the vtkfiles dir. The default is ‘’.</p>
</dd>
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>Name of the file if we’re reading in vtkfiles dir. The default 
is ‘image’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.read_mesh">
<span class="sig-name descname"><span class="pre">read_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mesh'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.read_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Read in the mesh from a file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh_path</strong><span class="classifier">str, optional</span></dt><dd><p>Path to the mesh, if none use the mesh directory. 
The default is None.</p>
</dd>
<dt><strong>suffix</strong><span class="classifier">str, optional</span></dt><dd><p>The suffix for the vtkfiles dir. The default is ‘’.</p>
</dd>
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>Name of the file if we’re reading in vtkfiles dir. The default 
is ‘mesh’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.read_scans">
<span class="sig-name descname"><span class="pre">read_scans</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.read_scans" title="Permalink to this definition">¶</a></dt>
<dd><p>Read all single scans from files.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.read_transforms">
<span class="sig-name descname"><span class="pre">read_transforms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.read_transforms" title="Permalink to this definition">¶</a></dt>
<dd><p>Have each SingleScan read a transform from file</p>
<dl class="simple">
<dt>suffix<span class="classifier">str, optional</span></dt><dd><p>Suffix for transforms directory if we are reading scans. 
The default is ‘’ which corresponds to the regular transforms
directory.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.set_empirical_cdf">
<span class="sig-name descname"><span class="pre">set_empirical_cdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.set_empirical_cdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the empirical cdf to the given values</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d-array</span></dt><dd><p>Bin values in empirical cdf.</p>
</dd>
<dt><strong>cdf</strong><span class="classifier">1d-array</span></dt><dd><p>Values of empirical cdf.</p>
</dd>
<dt><strong>bounds</strong><span class="classifier">tuple, optional</span></dt><dd><p>Bounding box for points making up cdf. The default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.transect_n_points">
<span class="sig-name descname"><span class="pre">transect_n_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_pts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.transect_n_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Get approximately n points around the transect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x0</strong><span class="classifier">float</span></dt><dd><p>Coordinate in project reference frame.</p>
</dd>
<dt><strong>y0</strong><span class="classifier">float</span></dt><dd><p>Coordinate in project reference frame.</p>
</dd>
<dt><strong>x1</strong><span class="classifier">float</span></dt><dd><p>Coordinate in project reference frame.</p>
</dd>
<dt><strong>y1</strong><span class="classifier">float</span></dt><dd><p>Coordinate in project reference frame.</p>
</dd>
<dt><strong>n_pts</strong><span class="classifier">int</span></dt><dd><p>Minimum number of points to acquire around transect.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">int, optional</span></dt><dd><p>Tolerance for number of points around transect to get. the default
is 1000.</p>
</dd>
<dt><strong>d0</strong><span class="classifier">float, optional</span></dt><dd><p>Starting distance. The default is 0.5.</p>
</dd>
<dt><strong>dmax</strong><span class="classifier">float, optional</span></dt><dd><p>Max distance to look for points. the default is 50 m.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>vtkPolyData, d</dt><dd><p>with the selected points in the project reference frame. And
d, the distance from the transect that we selected points.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.transect_points">
<span class="sig-name descname"><span class="pre">transect_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.transect_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the points within a distance d of transect defined by by points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x0</strong><span class="classifier">float</span></dt><dd><p>Coordinate in project reference frame.</p>
</dd>
<dt><strong>y0</strong><span class="classifier">float</span></dt><dd><p>Coordinate in project reference frame.</p>
</dd>
<dt><strong>x1</strong><span class="classifier">float</span></dt><dd><p>Coordinate in project reference frame.</p>
</dd>
<dt><strong>y1</strong><span class="classifier">float</span></dt><dd><p>Coordinate in project reference frame.</p>
</dd>
<dt><strong>d</strong><span class="classifier">float</span></dt><dd><p>Distance from transect to select points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>vtkPolyData</dt><dd><p>with the selected points in the project reference frame</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.update_man_class_fields">
<span class="sig-name descname"><span class="pre">update_man_class_fields</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">update_fields</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update_trans</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.update_man_class_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Update man_class table with the fields that are currently in
polydata_raw.</p>
<p>Requires that PointId’s haven’t changed!!!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>update_fields</strong><span class="classifier">list or ‘all’, optional</span></dt><dd><p>Which fields in man_class we want to update. If ‘all’ update all 
but Classification. The default is ‘all’.</p>
</dd>
<dt><strong>update_trans</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to update the transformation matrix values with the
current transformation. The default is True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.write_current_transforms">
<span class="sig-name descname"><span class="pre">write_current_transforms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.write_current_transforms" title="Permalink to this definition">¶</a></dt>
<dd><p>Have each SingleScan write its current transform to a file.</p>
<dl class="simple">
<dt>suffix<span class="classifier">str, optional</span></dt><dd><p>Suffix for transforms directory if we are reading scans. 
The default is ‘’ which corresponds to the regular transforms
directory.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.write_image">
<span class="sig-name descname"><span class="pre">write_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'image'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.write_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the image out to a file.</p>
<p>Can specify a suffix and a name for the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>output_path</strong><span class="classifier">str, optional</span></dt><dd><p>Output name for the file, if None use the mesh directory. 
The default is None.</p>
</dd>
<dt><strong>suffix</strong><span class="classifier">str, optional</span></dt><dd><p>The suffix for the vtkfiles dir. The default is ‘’.</p>
</dd>
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>Name of the file if we’re writing to vtkfiles dir. The default 
is ‘image’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.write_las_pdal">
<span class="sig-name descname"><span class="pre">write_las_pdal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'transformed'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_fields</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.write_las_pdal" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the data in the project to LAS using pdal</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>output_dir</strong><span class="classifier">str, optional</span></dt><dd><p>Directory to write to. If none defaults to project_path +
project_name + ‘lasfilespdal_output'. The default is None</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str, optional</span></dt><dd><p>Filename, if none uses project name. The default is None.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>Whether to write ‘raw’ points, ‘transformed’ points, or ‘filtered’
points. The default is ‘transformed’.</p>
</dd>
<dt><strong>skip_fields</strong><span class="classifier">list, optional</span></dt><dd><p>Fields to skip in writing. If this is ‘all’ then only write x,
y, z. Otherwise should be a list of field names. The default is []</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.write_merged_points">
<span class="sig-name descname"><span class="pre">write_merged_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.write_merged_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the transformed, merged points to a vtp file.</p>
<p>Uses the output of each scans get_polydata so should run
apply_transforms beforehand.
Parameters
———-
output_name : str, optional</p>
<blockquote>
<div><p>Output name for the file, if None use the project_name + 
‘_merged.xyz’. The default is None.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.write_mesh">
<span class="sig-name descname"><span class="pre">write_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mesh'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.write_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the mesh out to a file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>output_path</strong><span class="classifier">str, optional</span></dt><dd><p>Output name for the file, if None use the mesh directory. 
The default is None.</p>
</dd>
<dt><strong>suffix</strong><span class="classifier">str, optional</span></dt><dd><p>The suffix for the vtkfiles dir. The default is ‘’.</p>
</dd>
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>Name of the file if we’re writing to vtkfiles dir. The default 
is ‘mesh’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.write_plot_image">
<span class="sig-name descname"><span class="pre">write_plot_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">focal_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camera_position</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Elevation'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warp_scalars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roll</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'map'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">light</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(2000,</span> <span class="pre">1000)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.write_plot_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Write an image of the image to the snapshots folder.</p>
<p>Assumes we want an orthorectified image (mode=’map’) and we want the
default image name to just be the project name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z_min</strong><span class="classifier">float</span></dt><dd><p>Minimum z value to display colors.</p>
</dd>
<dt><strong>z_max</strong><span class="classifier">float</span></dt><dd><p>Maximum z value to display colors.</p>
</dd>
<dt><strong>focal_point</strong><span class="classifier">3 element array like</span></dt><dd><p>Focal point of the camera in the project’s reference frame.</p>
</dd>
<dt><strong>camera_position</strong><span class="classifier">3 element array like</span></dt><dd><p>Camera position in the project’s reference frame.</p>
</dd>
<dt><strong>field</strong><span class="classifier">str, optional</span></dt><dd><p>Which field in PointData to display. The default is ‘Elevation’</p>
</dd>
<dt><strong>warp_scalars</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to warp the scalars in the image to create 3D surface</p>
</dd>
<dt><strong>roll</strong><span class="classifier">float, optional</span></dt><dd><p>Camera roll in degrees. The default is 0.</p>
</dd>
<dt><strong>image_scale</strong><span class="classifier">float, optional</span></dt><dd><p>Image scale used in parallel projection. The default is 500.</p>
</dd>
<dt><strong>lower_threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Value of z to clip below. The default is -1000.</p>
</dd>
<dt><strong>upper_threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Value of z to clip above. The default is 1000.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>What kind of projection system to use. ‘Map’ indicates parallel
or orthorectified projection. The default is ‘map’.</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to display a colorbar.</p>
</dd>
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>Name to append to this snapshot. The default is ‘’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.Project.write_scans">
<span class="sig-name descname"><span class="pre">write_scans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_write_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.Project.write_scans" title="Permalink to this definition">¶</a></dt>
<dd><p>Write all single scans to files.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A directory to write all scans for this project to. If none write</strong></dt><dd></dd>
<dt><strong>to default npyfiles location. The default is None.</strong></dt><dd></dd>
<dt><strong>suffix</strong><span class="classifier">str, optional</span></dt><dd><p>Suffix for npyfiles directory if we are reading scans. The default
is ‘’ which corresponds to the regular npyfiles directory.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydar.ScanArea">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">ScanArea</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">registration_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">import_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'.1_.1_.01'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">load_scans</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">read_scans</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">import_las</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">create_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">las_fieldnames</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">70]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Manage multiple scans from the same area.</p>
<p>…</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>project_path</strong><span class="classifier">str</span></dt><dd><p>Path to folder containing all Riscan projects</p>
</dd>
<dt><strong>project_dict</strong><span class="classifier">dict</span></dt><dd><p>Dictionary containing each project object keyed on project_name</p>
</dd>
<dt><strong>registration_list</strong><span class="classifier">list</span></dt><dd><p>List of registration instructions, each element is a namedtuple
(project_name_0, project_name_1, reflector_list, mode, yaw_angle). 
The order of the list determines the order that actions are performed.</p>
</dd>
<dt><strong>difference_dict</strong><span class="classifier">dict</span></dt><dd><p>Dictionary containing the differences between pairs of scans</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 49%" />
<col style="width: 51%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>add_project(project_name)</strong></p></td>
<td><p>Add a project in project_path directory to project_dict</p></td>
</tr>
<tr class="row-even"><td><p><strong>compare_reflectors(project_name_0, project_name_1, delaunay=False,</strong></p></td>
<td><p>mode=’dist’) Calculate pwdists and plot reflector comparison project 0 to project 1</p></td>
</tr>
<tr class="row-odd"><td><p><strong>register_project(project_name_0, project_name_1, reflector_list, mode=’lS’)</strong></p></td>
<td><p>Register project 1 to project 0 using the reflectors in reflector_list.</p></td>
</tr>
<tr class="row-even"><td><p><strong>add_registration_tuple(registration_tuple, index=None)</strong></p></td>
<td><p>Add a registration tuple to the registration list.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>del_registration_tuple(index)</strong></p></td>
<td><p>Delete registration tuple from registration_list.</p></td>
</tr>
<tr class="row-even"><td><p><strong>register_all()</strong></p></td>
<td><p>Register all projects according to registration list.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>apply_snowflake_filter(shells)</strong></p></td>
<td><p>Apply a snowflake filter to each scan in each project.</p></td>
</tr>
<tr class="row-even"><td><p><strong>apply_snowflake_filter_2(z_diff, N, r_min)</strong></p></td>
<td><p>Apply a snowflake filter based on z difference with nearby points.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>merged_points_to_mesh(self, subgrid_x, subgrid_y, min_pts=100,</strong></p></td>
<td><p>alpha=0, overlap=0.1) For each project convert pointcloud to mesh.</p></td>
</tr>
<tr class="row-even"><td><p><strong>mesh_to_image(z_min, z_max, nx, ny, dx, dy, x0, y0)</strong></p></td>
<td><p>Interpolate mesh into image.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>difference_projects(project_name_0, project_name_1)</strong></p></td>
<td><p>Subtract project_0 from project_1 and store the result in difference_dict.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.add_project">
<span class="sig-name descname"><span class="pre">add_project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">import_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'.1_.1_.01'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">load_scans</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">read_scans</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">import_las</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">create_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">las_fieldnames</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">70]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.add_project" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new project to the project_dict (or overwrite existing project)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>project_name</strong><span class="classifier">str</span></dt><dd><p>Name of Riscan project to add</p>
</dd>
<dt><strong>poly</strong><span class="classifier">str, optional</span></dt><dd><p>The suffix describing which polydata to load. The default is
‘.1_.1_.01’.</p>
</dd>
<dt><strong>import_mode</strong><span class="classifier">str, optional</span></dt><dd><p>How to create polydata_raw, the base data for this SingleScan. 
Options are: ‘poly’ (read from Riscan generated poly), ‘read_scan’
(read saved vtp file), ‘import_las’ (use pdal to import from las
file generate by Riscan), ‘empty’ (create an empty polydata, 
useful if we just want to work with transformations). ‘import_npy’
(import from npyfiles directories) If value is None, then code 
will interpret values of read_scan and import_las
(deprecated method of specifying which to import) to maintain
backwards compatibility. The default is None.</p>
</dd>
<dt><strong>load_scans</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to actually load the scans. Often if we’re just
aligning successive scans loading all of them causes overhead.
The default is True.</p>
</dd>
<dt><strong>read_scans</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, each SingleScan object will be initialized to read the
raw polydata from where RiSCAN saved it. If True, read the saved
vtp file from in the scan area directory. Useful if we have saved
already filtered scans. The default is False.</p>
</dd>
<dt><strong>import_las: bool, optional</strong></dt><dd><p>If true (and read_scan is False) read in the las file instead of
the polydata. The default is False.</p>
</dd>
<dt><strong>create_id: bool, optional</strong></dt><dd><p>If true and PointID’s do not exist create PointIDs. The default
is True.</p>
</dd>
<dt><strong>las_fieldnames: list, optional</strong></dt><dd><p>List of fieldnames to load if we are importing from a las file
Must include ‘Points’. The default is None.</p>
</dd>
<dt><strong>class_list</strong><span class="classifier">list</span></dt><dd><p>List of categories this filter will return, if special value: 
‘all’ Then we do not have a selection filter and we pass through 
all points. The default is [0, 1, 2, 70].</p>
</dd>
<dt><strong>suffix</strong><span class="classifier">str, optional</span></dt><dd><p>Suffix for npyfiles directory if we are reading scans. The default
is ‘’ which corresponds to the regular npyfiles directory.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.add_registration_tuple">
<span class="sig-name descname"><span class="pre">add_registration_tuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">registration_tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.add_registration_tuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Add registration tuple to registration list, if no index given append.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>registration_tuple</strong><span class="classifier">tuple</span></dt><dd><p>Registration tuple to add.</p>
</dd>
<dt><strong>index</strong><span class="classifier">int, optional</span></dt><dd><p>Index at which to add tuple or add at end if None. 
The default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.apply_snowflake_filter">
<span class="sig-name descname"><span class="pre">apply_snowflake_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shells</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.apply_snowflake_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a snowflake filter to each project.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shells</strong><span class="classifier">array-like of tuples</span></dt><dd><p>shells is an array-like set of tuples where each tuple is four
elements long (inner_r, outer_r, point_radius, neighbors). <a href="#id5"><span class="problematic" id="id6">*</span></a>_r
define the inner and outer radius of a halo defining shell. 
point_radius is radius for vtkRadiusOutlierRemoval to look at
(if 0, remove all points). Neighbors is number of neighbors that
must be within point_radius (if 0, keep all points)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.apply_snowflake_filter_2">
<span class="sig-name descname"><span class="pre">apply_snowflake_filter_2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z_diff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_min</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.apply_snowflake_filter_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter snowflakes based on their vertical distance from nearby points.</p>
<p>Here we exploit the fact that snowflakes (and for that matter power
cables and some other human objects) are higher than their nearby
points. The filter steps through each point in the transformed
dataset and compares it’s z value with the mean of the z-values of
the N closest points. If the difference exceeds z_diff then set the
Classification for that point to be 65. Also, there is a shadow around the
base of the scanner so all points within there must be spurious. We
filter all points within r_min</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z_diff</strong><span class="classifier">float</span></dt><dd><p>Maximum vertical difference in m a point can have from its 
neighborhood.</p>
</dd>
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of neighbors to find.</p>
</dd>
<dt><strong>r_min</strong><span class="classifier">float</span></dt><dd><p>Radius of scanner in m within which to filter all points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.compare_reflectors">
<span class="sig-name descname"><span class="pre">compare_reflectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_name_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_name_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delaunay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dist'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_tiepoints_transformed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.compare_reflectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the comparison of pwdist changes from project 0 to 1</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>project_name_0</strong><span class="classifier">str</span></dt><dd><p>Name of project 0. Presumably already transformed to desired loc.</p>
</dd>
<dt><strong>project_name_1</strong><span class="classifier">str</span></dt><dd><p>Name of project 1. Project we are comparing (usually later)</p>
</dd>
<dt><strong>delaunay</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to plot just delaunay lines. The default is False.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>Whether to display distance change (‘dist’) or strain (‘strain’). 
The default is ‘dist’.</p>
</dd>
<dt><strong>use_tiepoints_transformed</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to display tiepoints in their transformed locations.
The default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.del_registration_tuple">
<span class="sig-name descname"><span class="pre">del_registration_tuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.del_registration_tuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete registration tuple from position specified by index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">int</span></dt><dd><p>Index of registration tuple to delete.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.difference_histogram">
<span class="sig-name descname"><span class="pre">difference_histogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_name_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_name_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">difference_field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Elevation'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.difference_histogram" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ax</strong><span class="classifier">matplotlib axis object</span></dt><dd><p>Axis to plot on.</p>
</dd>
<dt><strong>project_name_0</strong><span class="classifier">str</span></dt><dd><p>Name of project to subtract (usually older).</p>
</dd>
<dt><strong>project_name_1</strong><span class="classifier">str</span></dt><dd><p>Name of project to subtract from (usually younger).</p>
</dd>
<dt><strong>difference_field</strong><span class="classifier">str, optional</span></dt><dd><p>Which field in ImageData to use. The default is ‘Elevation’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.difference_projects">
<span class="sig-name descname"><span class="pre">difference_projects</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_name_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_name_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">difference_field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Elevation'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">confidence_interval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.difference_projects" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract project_0 from project_1 and store in difference_dict.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>project_name_0</strong><span class="classifier">str</span></dt><dd><p>Name of project to subtract (usually older).</p>
</dd>
<dt><strong>project_name_1</strong><span class="classifier">str</span></dt><dd><p>Name of project to subtract from (usually younger).</p>
</dd>
<dt><strong>difference_field</strong><span class="classifier">str, optional</span></dt><dd><p>Which field in ImageData to use. The default is ‘Elevation’</p>
</dd>
<dt><strong>confidence_interval</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to estimate a confidence interval as well. The default
is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.display_difference">
<span class="sig-name descname"><span class="pre">display_difference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_name_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_name_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diff_window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rainbow'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.display_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Display image in vtk interactive window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>project_name_0</strong><span class="classifier">str</span></dt><dd><p>Name of project to subtract (usually older).</p>
</dd>
<dt><strong>project_name_1</strong><span class="classifier">str</span></dt><dd><p>Name of project to subtract from (usually younger).</p>
</dd>
<dt><strong>diff_window</strong><span class="classifier">float</span></dt><dd><p>Scale of differences to display in color in m.</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">str, optional</span></dt><dd><p>Name of matplotlib colormap to use. The default is ‘rainbow’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.display_warp_difference">
<span class="sig-name descname"><span class="pre">display_warp_difference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_name_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_name_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diff_window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Elevation_mean_fill'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rainbow'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_scanners</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scanner_color_0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Yellow'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scanner_color_1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Fuchsia'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scanner_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">150</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.display_warp_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the surface of the image from project_name_1 colored by diff.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>project_name_0</strong><span class="classifier">str</span></dt><dd><p>Name of project to subtract (usually older).</p>
</dd>
<dt><strong>project_name_1</strong><span class="classifier">str</span></dt><dd><p>Name of project to subtract from (usually younger).</p>
</dd>
<dt><strong>diff_window</strong><span class="classifier">float</span></dt><dd><p>Scale of differences to display in color in m.</p>
</dd>
<dt><strong>field</strong><span class="classifier">str, optional</span></dt><dd><p>The field in PointData of project_name_1 to use as warped scalars.
The default is ‘Elevation_mean_fill’</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">str, optional</span></dt><dd><p>Name of matplotlib colormap to use. The default is ‘rainbow’</p>
</dd>
<dt><strong>profile_list</strong><span class="classifier">list, optional</span></dt><dd><p>List of keys of profiles in the profiles dict to display. The 
default is [].</p>
</dd>
<dt><strong>show_scanners</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to show the scanners. The default is False.</p>
</dd>
<dt><strong>scanner_color_0</strong><span class="classifier">str, optional</span></dt><dd><dl class="simple">
<dt>Name of the color to display project 0 scanners.</dt><dd><p>The default is ‘Yellow’</p>
</dd>
</dl>
</dd>
<dt><strong>scanner_color_1</strong><span class="classifier">str, optional</span></dt><dd><dl class="simple">
<dt>Name of the color to display project 0 scanners.</dt><dd><p>The default is ‘Fuchsia’</p>
</dd>
</dl>
</dd>
<dt><strong>scanner_length</strong><span class="classifier">float, optional</span></dt><dd><p>Length of the ray indicating the scanner’s start orientation in m.
The default is 150</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.kernel_alignment">
<span class="sig-name descname"><span class="pre">kernel_alignment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_name_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_name_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin_width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">800000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_dist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">250</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blur</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.005</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff_t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0005</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff_r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_optimization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.kernel_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Align each single scan in project 1 with project 0 using geomloss</p>
<p>This function requires you to be running python from the docker group
and have the jupyter-keops container running. We will first subset
the two scans to areas with high overlapping point density. Then,
we apply compute_kernel_alignment.py to find the best fitting rigid
transformation. Finally, we load in this transformation.</p>
<p>This function updates the current_transform for each single scan and
applies current_transform to each scan.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.kernel_alignment_ss">
<span class="sig-name descname"><span class="pre">kernel_alignment_ss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_name_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_name_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scan_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin_width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">800000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_dist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">250</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blur</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.005</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff_t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0005</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff_r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_optimization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.kernel_alignment_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Align single scan in project 1 with project 0 using geomloss</p>
<p>This function requires you to be running python from the docker group
and have the jupyter-keops container running. We will first subset
the two scans to areas with high overlapping point density. Then,
we apply compute_kernel_alignment.py to find the best fitting rigid
transformation. Finally, we load in this transformation.</p>
<p>This function will load the</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.max_alignment_ss">
<span class="sig-name descname"><span class="pre">max_alignment_ss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_name_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_name_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scan_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_diff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_closest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_thresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">az_thresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_intcpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.max_alignment_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Align singlescan with project 0 using local maxima as keypoints.</p>
<p>This function breaks each pointcloud up into bins and finds the point
with the maximum z value in each bin, resulting in a pair of possible
keypoints for each bin. Then we select only those pairs whose
euclidean distance is less than max_diff and find the rigid
transformation which aligns the pairs of points in a least squares
sense.</p>
<p>This function returns the rigid transform as a numpy 4x4 array and
the history dict corresponding to this transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>project_name_0</strong><span class="classifier">str</span></dt><dd><p>The reference project we’re aligning project_1 with.</p>
</dd>
<dt><strong>project_name_1</strong><span class="classifier">str</span></dt><dd><p>The project we are aligning.</p>
</dd>
<dt><strong>scan_name</strong><span class="classifier">str</span></dt><dd><p>The scan we are aligning in the project we’re aligning.</p>
</dd>
<dt><strong>w0</strong><span class="classifier">float, optional</span></dt><dd><p>Bin width in the zeroth dimension. The default is 5.</p>
</dd>
<dt><strong>w1</strong><span class="classifier">float, optional</span></dt><dd><p>Bin width in the first dimension. The default is 5.</p>
</dd>
<dt><strong>max_diff</strong><span class="classifier">float, optional</span></dt><dd><p>The max distance (in m) between two gridded local maxima for us
to try to align them. The default is 0.1.</p>
</dd>
<dt><strong>return_count</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to return the number of keypoint pairs as the 3rd
return. The default is False.</p>
</dd>
<dt><strong>use_closest</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, just align off of the closest singlescan in project_0
as opposed to all of project_0. The default is False.</p>
</dd>
<dt><strong>p_thresh</strong><span class="classifier">float, optional</span></dt><dd><p>Radial difference threshold for keypoint pairs if using 
cylindrical divergence. Will only be used if max_diff is None.
The default is None.</p>
</dd>
<dt><strong>az_thresh</strong><span class="classifier">float, optional</span></dt><dd><p>Azimuthal difference threshold for keypoint pairs if using 
cylindrical divergence. Will only be used if max_diff is None.
The default is None.</p>
</dd>
<dt><strong>z_intcpt</strong><span class="classifier">float, optional</span></dt><dd><p>Z intercept difference threshold for keypoint pairs if using 
cylindrical divergence. Will only be used if max_diff is None.
The default is None.</p>
</dd>
<dt><strong>z_slope</strong><span class="classifier">float, optional</span></dt><dd><p>Z slope difference threshold for keypoint pairs if using 
cylindrical divergence. Will only be used if max_diff is None.
The default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray, dict, int (optional)</dt><dd><p>Returns the 4x4 array that transforms our singlescan’s local
maxima to align with project_0’s local maxima. Also returns
history_dict for the transform. Optionally returns the number of
keypoint pairs.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.merged_points_to_mesh">
<span class="sig-name descname"><span class="pre">merged_points_to_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subgrid_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subgrid_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_pts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overlap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.merged_points_to_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Create mesh from all points in singlescans.</p>
<p>Note, we use a delaunay2D filter to create this mesh. The filter
encounters memory issues for large numbers of input points. So before
the mesh creation step, we break the project up into a subgrid of 
smaller chunks and then we apply the delaunay2D filter to each of 
these and save the output in the mesh object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>subgrid_x</strong><span class="classifier">float</span></dt><dd><p>x spacing, in m for the subgrid.</p>
</dd>
<dt><strong>subgrid_y</strong><span class="classifier">float</span></dt><dd><p>y spacing, in m for the subgrid.</p>
</dd>
<dt><strong>min_pts</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum number of points for a subgrid region below which dont 
include data from this region. The default is 100.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, optional</span></dt><dd><p>Alpha value for vtkDelaunay2D filter. Inverse of how large of data
gaps to interpolate over in m. The default is 0.</p>
</dd>
<dt><strong>overlap</strong><span class="classifier">float, optional</span></dt><dd><p>Overlap value indicates how much overlap to permit between subgrid
chunks in meters. The default is 0.1</p>
</dd>
<dt><strong>sub_list</strong><span class="classifier">list, optional</span></dt><dd><p>List of project names to apply to if not whole project.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.mesh_to_image">
<span class="sig-name descname"><span class="pre">mesh_to_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ny</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yaw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.mesh_to_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate mesh at regularly spaced points.</p>
<p>Currently this image can only be axis aligned, if you want a different
orientation then you need to apply the appropriate transformation to
the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nx</strong><span class="classifier">int</span></dt><dd><p>Number of gridcells in x direction.</p>
</dd>
<dt><strong>ny</strong><span class="classifier">int</span></dt><dd><p>Number of gridcells in y direction.</p>
</dd>
<dt><strong>dx</strong><span class="classifier">int</span></dt><dd><p>Width of gridcells in x direction.</p>
</dd>
<dt><strong>dy</strong><span class="classifier">int</span></dt><dd><p>Width of gridcells in y direction.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">float</span></dt><dd><p>x coordinate of the origin in m.</p>
</dd>
<dt><strong>y0</strong><span class="classifier">float</span></dt><dd><p>y coordinate of the origin in m.</p>
</dd>
<dt><strong>yaw</strong><span class="classifier">float, optional</span></dt><dd><p>yaw angle in degerees of image to create, for generating 
non-axis aligned image. The default is 0</p>
</dd>
<dt><strong>sub_list</strong><span class="classifier">list, optional</span></dt><dd><p>If given, only apply mesh to image on the projects in sub_list.
The default is [].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.register_all">
<span class="sig-name descname"><span class="pre">register_all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.register_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Register all projects in self according to registration_list.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.register_project">
<span class="sig-name descname"><span class="pre">register_project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_name_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_name_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reflector_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'LS'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_tiepoints_transformed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yaw_angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.register_project" title="Permalink to this definition">¶</a></dt>
<dd><p>Register project_1 to project_0 using reflectors in reflector_list.</p>
<p>Calculates 4x4 transform matrix and adds it to project_1’s 
tiepointlist and to each SingleScan in Project_1’s tranform_dict. The
transform is keyed on the tuple (project_name_0 + ‘_’ + mode, 
str_reflector_list). Applies the transform to project_1’s tiepointlist
and applies sop and that transform to each SingleScan in project_1.</p>
<p>For the special case where we just want to set a project’s
registration to be its own prcs (leave the tiepoints as is) we set
the project_name_0 to be the same as project_name_1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>project_name_0</strong><span class="classifier">str</span></dt><dd><p>Name of project to register other project to.</p>
</dd>
<dt><strong>project_name_1</strong><span class="classifier">str</span></dt><dd><p>Name of project we want to register.</p>
</dd>
<dt><strong>reflector_list</strong><span class="classifier">list</span></dt><dd><p>List of reflectors to use in registration.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>‘LS’ or ‘Yaw”, the mode of the registration. See 
Tiepointlist.calc_transformation for more detail. 
The default is ‘LS’.</p>
</dd>
<dt><strong>use_tiepoints_transformed</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to register to tiepoints_transformed in project_0.
The default is True.</p>
</dd>
<dt><strong>yaw_angle</strong><span class="classifier">float, optional</span></dt><dd><p>If the mode is ‘Trans’ this is the angle (in radians) by which to
change the heading of the scan. The default is 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.write_plot_difference_projects">
<span class="sig-name descname"><span class="pre">write_plot_difference_projects</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_name_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_name_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diff_window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.write_plot_difference_projects" title="Permalink to this definition">¶</a></dt>
<dd><p>Display a plot showing the difference between two projects</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>project_name_0</strong><span class="classifier">str</span></dt><dd><p>Name of project to subtract (usually older).</p>
</dd>
<dt><strong>project_name_1</strong><span class="classifier">str</span></dt><dd><p>Name of project to subtract from (usually younger).</p>
</dd>
<dt><strong>diff_window</strong><span class="classifier">float</span></dt><dd><p>Scale of differences to display in color in m.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Path and name of file to write, defaults to snapshots folder if “”</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.write_plot_warp_difference">
<span class="sig-name descname"><span class="pre">write_plot_warp_difference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_name_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_name_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diff_window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camera_position</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">focal_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roll</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Elevation'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'RdBu_r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">light</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(2000,</span> <span class="pre">1000)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.write_plot_warp_difference" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>project_name_0</strong><span class="classifier">str</span></dt><dd><p>Name of project to subtract (usually older).</p>
</dd>
<dt><strong>project_name_1</strong><span class="classifier">str</span></dt><dd><p>Name of project to subtract from (usually younger).</p>
</dd>
<dt><strong>diff_window</strong><span class="classifier">float</span></dt><dd><p>Scale of differences to display in color in m.</p>
</dd>
<dt><strong>camera_position</strong><span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
<dt><strong>focal_point</strong><span class="classifier">TYPE</span></dt><dd><p>DESCRIPTION.</p>
</dd>
<dt><strong>roll</strong><span class="classifier">float, optional</span></dt><dd><p>Camera roll angle in degrees. The default is 0.</p>
</dd>
<dt><strong>field</strong><span class="classifier">str, optional</span></dt><dd><p>DESCRIPTION. The default is ‘Elevation_mean_fill’.</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">str, optional</span></dt><dd><p>matplotlib colormap to use for differences. The default is 
‘rainbow’.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str, optional</span></dt><dd><p>full filename (w/ path) to write to. If empty will be placed
in snapshots folder. The default is “”.</p>
</dd>
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>string to append to filename if filename is empty. The default
is ‘’.</p>
</dd>
<dt><strong>light</strong><span class="classifier">vtkLight, optional</span></dt><dd><p>If desired add a light to the scene to replace the default vtk
lighting. The default is None</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to render a colorbar. The default is True</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.z_align_all">
<span class="sig-name descname"><span class="pre">z_align_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_pt_dens</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_diff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frac_exceed_diff_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin_reduc_op</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'min'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diff_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.z_align_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Align successive scans on the basis of their gridded values</p>
<p>!This function does not modify the tiepoint locations so it should 
only be run after all tiepoint registration steps are done. It also
requires that there hasn’t been ice deformation and will try to not
run if the fraction that changed by more than the diff cutoff exceeds
frac_exceed_diff_cutoff.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>w0</strong><span class="classifier">float, optional</span></dt><dd><p>Grid cell width in x dimension (m). The default is 10.</p>
</dd>
<dt><strong>w1</strong><span class="classifier">float, optional</span></dt><dd><p>Grid cell width in y dimension (m). The default is 10.</p>
</dd>
<dt><strong>min_pt_dens</strong><span class="classifier">float, optional</span></dt><dd><p>minimum density of points/m^2 for us to compare grid cells from
projects 0 and 1. The default is 30.</p>
</dd>
<dt><strong>max_diff</strong><span class="classifier">float, optional</span></dt><dd><p>Maximum difference in minima to consider (higher values must be
noise) in m. The default is 0.1.</p>
</dd>
<dt><strong>frac_exceed_diff_cutoff</strong><span class="classifier">float, optional</span></dt><dd><p>If the max_diff cutoff is causing us to discard greater than this
fraction of the gridcells that meet the point density requirements
that probably means the ice has moved, so raise a warning</p>
</dd>
<dt><strong>bin_reduc_op</strong><span class="classifier">str, optional</span></dt><dd><p>What type of gridded reduction to apply. Options are ‘min’, ‘mean’
and ‘mode’. The default is ‘min’</p>
</dd>
<dt><strong>diff_mode</strong><span class="classifier">str, optional</span></dt><dd><p>Which property of the difference distribution to set to zero. The
options are ‘mean’, ‘median’ and ‘mode’. The default is ‘mean’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.z_alignment">
<span class="sig-name descname"><span class="pre">z_alignment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_name_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_name_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_pt_dens</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_diff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frac_exceed_diff_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin_reduc_op</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'min'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diff_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.z_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Align successive scans on the basis of their gridded values</p>
<p>!This function does not modify the tiepoint locations so it should 
only be run after all tiepoint registration steps are done. It also
requires that there hasn’t been ice deformation and will try to not
run if the fraction that changed by more than the diff cutoff exceeds
frac_exceed_diff_cutoff.
Parameters
———-
project_name_0 : str</p>
<blockquote>
<div><p>The reference project we’re trying to align project_1 with</p>
</div></blockquote>
<dl class="simple">
<dt>project_name_1<span class="classifier">str</span></dt><dd><p>The project we’re aligning with project_0</p>
</dd>
<dt>w0<span class="classifier">float, optional</span></dt><dd><p>Grid cell width in x dimension (m). The default is 10.</p>
</dd>
<dt>w1<span class="classifier">float, optional</span></dt><dd><p>Grid cell width in y dimension (m). The default is 10.</p>
</dd>
<dt>min_pt_dens<span class="classifier">float, optional</span></dt><dd><p>minimum density of points/m^2 for us to compare grid cells from
projects 0 and 1. The default is 30.</p>
</dd>
<dt>max_diff<span class="classifier">float, optional</span></dt><dd><p>Maximum difference in minima to consider (higher values must be
noise) in m. The default is 0.1.</p>
</dd>
<dt>frac_exceed_diff_cutoff<span class="classifier">float, optional</span></dt><dd><p>If the max_diff cutoff is causing us to discard greater than this
fraction of the gridcells that meet the point density requirements
that probably means the ice has moved, so raise a warning</p>
</dd>
<dt>bin_reduc_op<span class="classifier">str, optional</span></dt><dd><p>What type of gridded reduction to apply. Options are ‘min’, ‘mean’
and ‘mode’. The default is ‘min’</p>
</dd>
<dt>diff_mode<span class="classifier">str, optional</span></dt><dd><p>Which property of the difference distribution to set to zero. The
options are ‘mean’, ‘median’ and ‘mode’. The default is ‘mean’</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.ScanArea.z_alignment_ss">
<span class="sig-name descname"><span class="pre">z_alignment_ss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_name_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_name_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scan_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_pt_dens</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_diff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin_reduc_op</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'min'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.ScanArea.z_alignment_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Align successive scans on the basis of their gridded minima</p>
<p>ss version is for looking at the change in just a singlescan</p>
<p>!This function does not modify the tiepoint locations so it should 
only be run after all tiepoint registration steps are done. It also
requires that there hasn’t been ice deformation and will try to not
run if the fraction that changed by more than the diff cutoff exceeds
frac_exceed_diff_cutoff.
Parameters
———-
project_name_0 : str</p>
<blockquote>
<div><p>The reference project we’re trying to align project_1 with</p>
</div></blockquote>
<dl class="simple">
<dt>project_name_1<span class="classifier">str</span></dt><dd><p>The project we’re aligning with project_0</p>
</dd>
<dt>w0<span class="classifier">float, optional</span></dt><dd><p>Grid cell width in x dimension (m). The default is 10.</p>
</dd>
<dt>w1<span class="classifier">float, optional</span></dt><dd><p>Grid cell width in y dimension (m). The default is 10.</p>
</dd>
<dt>min_pt_dens<span class="classifier">float, optional</span></dt><dd><p>minimum density of points/m^2 for us to compare grid cells from
projects 0 and 1. The default is 30.</p>
</dd>
<dt>max_diff<span class="classifier">float, optional</span></dt><dd><p>Maximum difference in minima to consider (higher values must be
noise) in m. The default is 0.1.</p>
</dd>
<dt>bin_reduc_op<span class="classifier">str, optional</span></dt><dd><p>What type of gridded reduction to apply. Options are ‘min’, ‘mean’
and ‘mode’. The default is ‘min’</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>diff</strong><span class="classifier">ndarray</span></dt><dd><p>Array containing gridded minima differences</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydar.SingleScan">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">SingleScan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scan_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">import_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'.1_.1_.01'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">read_scan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">import_las</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">create_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">las_fieldnames</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">70]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">read_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Container for single lidar scan and methods for displaying it.</p>
<p>…</p>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>project_path</strong><span class="classifier">str</span></dt><dd><p>Path to folder containing all Riscan projects.</p>
</dd>
<dt><strong>project_name</strong><span class="classifier">str</span></dt><dd><p>Name of Riscan project.</p>
</dd>
<dt><strong>scan_name</strong><span class="classifier">str</span></dt><dd><p>Typically ScanPos0XX where XX is the scan number.</p>
</dd>
<dt><strong>poly</strong><span class="classifier">int</span></dt><dd><p>Which polydata from the list to take.</p>
</dd>
<dt><strong>transform_dict</strong><span class="classifier">dict</span></dt><dd><p>dict of vtkTransforms linked with this single scan.</p>
</dd>
<dt><strong>transform</strong><span class="classifier">vtkTransform</span></dt><dd><p>pipelined, concatenated vtkTransform to apply to this scan.</p>
</dd>
<dt><strong>transformFilter</strong><span class="classifier">vtkTransformPolyDataFilter</span></dt><dd><p>filter that applies the transform above</p>
</dd>
<dt><strong>filterName</strong><span class="classifier">str</span></dt><dd><p>name of the current filter whose output is in currentFilter</p>
</dd>
<dt><strong>currentFilter</strong><span class="classifier">vtkThresholdPoints</span></dt><dd><p>vtkThresholdPoints with all transformed points that haven’t been 
filtered out.</p>
</dd>
<dt><strong>filteredPoints</strong><span class="classifier">vtkThresholdPoints</span></dt><dd><p>vtkThresholdPoints containing all points that have been filtered out.</p>
</dd>
<dt><strong>filterDict</strong><span class="classifier">dict</span></dt><dd><p>dict of vtkFilter objects</p>
</dd>
<dt><strong>mapper</strong><span class="classifier">vtkPolyDataMapper</span></dt><dd><p>vtk mapper object</p>
</dd>
<dt><strong>actor</strong><span class="classifier">vtkActor</span></dt><dd><p>vtk actor object</p>
</dd>
<dt><strong>polydata_raw</strong><span class="classifier">vtkPolyData</span></dt><dd><p>Raw data read in from Riscan, we will add arrays to PointData. This
polydata’s PointData includes an array Classification. This is a uint8
array with the classification of points defined as in the LAS 
specification from ASPRS: 
<a class="reference external" href="https://www.asprs.org/wp-content/uploads/2019/07/LAS_1_4_r15.pdf">https://www.asprs.org/wp-content/uploads/2019/07/LAS_1_4_r15.pdf</a> 
Plus additional catagories defined here
0 : Created, Never Classified
1 : Unclassified
2 : Ground
6 : Building
7 : Low Point (Noise)
64: High Elevation (Classified by elevation_filter)
65: Snowflake (Classified by returnindex filter)
66: Reflectance (high reflectance points and neighborhoods if desired)
67: Pole
68: Human
69: Snowmobile
70: Road
71: Flag
72: Wire
73: Manually Removed (mostly the ship and logistics area)</p>
</dd>
<dt><strong>dsa_raw</strong><span class="classifier">vtk.numpy_interface.dataset_adapter.Polydata</span></dt><dd><p>dataset adaptor object for interacting with polydata_raw</p>
</dd>
<dt><strong>man_class</strong><span class="classifier">pandas dataframe</span></dt><dd><p>Dataframe containing information on manually classified points. The
dataframe is keyed on PointId and contains:</p>
<blockquote>
<div><dl class="simple">
<dt>X, Y, Z: position of the point in the scanner’s own coordinate </dt><dd><p>system</p>
</dd>
<dt>trans_XX: transformation matrix where the point was selected. To</dt><dd><p>simplify I/O we break into the 12 components 00-11. We don’t
need 16 because the last row of a rigid transformation is
0 0 0 1.</p>
</dd>
<dt>Linearity, Planarity, Scattering, Verticality: the four</dt><dd><p>Demantke2011 dimensionalities in the reference frame 
corresponding to that transformation matrix.</p>
</dd>
<dt>elev: The vertical position of the point in the given reference </dt><dd><p>frame</p>
</dd>
</dl>
<p>dist: The distance from the scanner
Amplitude: measures of the pulse quality
Classification: Manual classification (number)</p>
</div></blockquote>
<p>The expected usage here is that the scan was orginally loaded from a
LAS file and that the PointId field created on that original loading
is the same as the PointId’s of the points we add to this dataframe.
Doing otherwise may cause duplicate points which could cause errors
later on.</p>
</dd>
<dt><strong>raw_history_dict</strong><span class="classifier">dict</span></dt><dd><p>A dict containing the history of modification dependencies to the
SingleScan as a tree. Every node in the tree contains the following
attributes as strings: “type”, “git_hash”, “method”. It then contains
0 (if it’s a source), 1 (filters), or 2 geometric 
inputs, as history_dicts of themselves. Then it contains an arbitrary
number of parameters. If the node has two input geometries, then the
output is considered to be the first geometry acting on the zeroth
(if some sense of ordering is required). There are two kinds of 
geometric objects, pointsets (e.g. lidar point clouds, reflector lists)
and transforms. 
Node examples:
“type”: “Transformer”
“git_hash”: 
“method”:
“input_0”: pointset
“input_1”: transform
the output of this is a pointset (input 0 transformed by input 1)</p>
<p>“type”: “Transform Computer”
“git_hash”: 
“method”:
“input_0”: pointset
“input_1”: pointset
“params”: {…}
the output of this is a transform (aligning input 1 with input 0)</p>
<p>“type”: “Transform Concatenator”
“git_hash”: 
“method”:
“input_0”: transform
“input_1”: transform
“params”: {…}
the output of this  a transform, the result of transforming by 
input_0 followed by input_1</p>
<p>“type”: “Pointset Aggregator”
“git_hash”: 
“method”:
“input_0”: pointset
“input_1”: pointset
the output of this is a pointset (input_0 and input_1 concatenated)</p>
<p>“type”: “Filter”
“git_hash”:
“method”:
“input_0”: pointset
“params”: {…}
the output of this is a pointset that’s a subset of input_0</p>
<p>“type”: “Scalar Modifier”
“git_hash”:
“method”:
“name”:
“input_0”: pointset
“params”: {…}
the output of this is a pointset with the same geometry as input_0</p>
<p>“type”: “Pointset Source”
“git_hash”:
“method”:
“filename”: str
“params”: {…}
the output of this is pointset. Note, this is only appropriate for
the first time we import a pointset from RiSCAN, if we are loading
saved intermediate data we should also load its history_dict.</p>
<p>“type”: “Transform Source”
“git_hash”:
“method”:
“filename”: str
“params”: {…}
the output of this is a transform. If filename is empty and params
is empty then identity transform is assumed.</p>
</dd>
<dt><strong>transformed_history_dict</strong><span class="classifier">dict</span></dt><dd><p>Same structure as raw_history_dict. self.raw_history_dict should be
the “input_0” value.
NOTE: here input_0 is passed by reference so that if for example,
we add arrays to polydata_raw (via “Scalar_Modifier”) that carries
through.
“type”: “Transformer”
“git_hash”: 
“method”:
“input_0”: self.raw_history_dict
“input_1”: (dict corresponding to the current transform,)</p>
</dd>
<dt><strong>filt_history_dict</strong><span class="classifier">dict</span></dt><dd><p>Same structure as raw_history_dict. self.transformed_history_dict
should be the input_0 value:
“type”: “Filter”
“git_hash”:
“method”:
“input_0”: self.transformed_history_dict
“params”: {…}
NOTE: here input_0 is passed by reference so that if for example,
we add arrays to polydata_raw (via “Scalar_Modifier”) that carries
through.</p>
</dd>
<dt><strong>trans_history_dict</strong><span class="classifier">dict</span></dt><dd><p>for each transformation in transform_dict gives the node to the 
history tree, keyed off the same key.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pydar.SingleScan.clear_classification" title="pydar.SingleScan.clear_classification"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear_classification</span></code></a>()</p></td>
<td><p>Reset Classification for all points to 0</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>write_scan()</strong></p></td>
<td><p>Writes the scan to a file to save the filters</p></td>
</tr>
<tr class="row-even"><td><p><strong>read_scan()</strong></p></td>
<td><p>Reads the scan from a file, replacing the RiSCAN version.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>write_current_transform()</strong></p></td>
<td><p>Writes the current transform and its history_dict to files.</p></td>
</tr>
<tr class="row-even"><td><p><strong>read_transform()</strong></p></td>
<td><p>Reads a transform from file and places it in current transforms.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>load_man_class()</strong></p></td>
<td><p>Load the manual classification table</p></td>
</tr>
<tr class="row-even"><td><p><strong>apply_transforms(transform_list)</strong></p></td>
<td><p>updates transform to be concatenation of transforms in transform list.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>add_sop()</strong></p></td>
<td><p>load the appropriate SOP matrix into transform_dict</p></td>
</tr>
<tr class="row-even"><td><p><strong>add_z_offset(z_offset)</strong></p></td>
<td><p>add a z_offset transformation to transform_dict</p></td>
</tr>
<tr class="row-odd"><td><p><strong>add_transform(key, matrix)</strong></p></td>
<td><p>add a transform to transform_dict</p></td>
</tr>
<tr class="row-even"><td><p><strong>update_current_filter(class_list)</strong></p></td>
<td><p>update the current filter object with a new class_list</p></td>
</tr>
<tr class="row-odd"><td><p><strong>create_elevation_pipeline(z_min, z_max, lower_threshold=-1000,</strong></p></td>
<td><p>upper_threshold=1000) create mapper and actor for displaying points with colors by elevation</p></td>
</tr>
<tr class="row-even"><td><p><strong>get_polydata()</strong></p></td>
<td><p>Returns the polydata object for the current settings of transforms and filters.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>create_normals(radius=2, max_nn=30)</strong></p></td>
<td><p>Estimate point normals (using Open3D).</p></td>
</tr>
<tr class="row-even"><td><p><strong>create_z_sigma()</strong></p></td>
<td><p>For the current value of the transformation, project the pointwise uncertainty spheroids onto the z-axis and save in PointData.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>apply_elevation_filter(z_max)</strong></p></td>
<td><p>Filter out all points above a certain height. Sets the flag in Classification to 64.</p></td>
</tr>
<tr class="row-even"><td><p><strong>apply_snowflake_filter_2(z_diff, N, r_min):</strong></p></td>
<td><p>Filter snowflakes based on their vertical distance from nearby points.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>apply_snowflake_filter_3(z_std_mult, leafsize):</strong></p></td>
<td><p>Filter points as snowflakes based on whether their z value in the transformed reference frame exceeds z_std_mult multiples of the mean z values for points nearby (within a bucket of size, leafsize)</p></td>
</tr>
<tr class="row-even"><td><p><strong>apply_snowflake_filter_returnindex(cylinder_rad, radial_precision)</strong></p></td>
<td><p>Filter snowflakes based on their return index and whether they are on the border of the visible region.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>apply_manual_filter(corner_coords, normal=(0, 0, 1), category=73)</strong></p></td>
<td><p>Classify points by a selection loop.</p></td>
</tr>
<tr class="row-even"><td><p><strong>random_voxel_downsample_filter(wx, wy, wz, seed=1234)</strong></p></td>
<td><p>Subset the filtered pointcloud randomly by voxels. Replaces Polydata!!</p></td>
</tr>
<tr class="row-odd"><td><p><strong>apply_man_class()</strong></p></td>
<td><p>For points that we have manually classified, set their classification.</p></td>
</tr>
<tr class="row-even"><td><p><strong>update_man_class(pdata, classification)</strong></p></td>
<td><p>Update the points in man_class with the points in pdata.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>update_man_class_fields(update_fields=’all’, update_trans=True)</strong></p></td>
<td><p>Update the man_class table with values from the fields currently in polydata_raw. Useful, for example if we’ve improved the HAG filter and don’t want to have to repick all points.</p></td>
</tr>
<tr class="row-even"><td><p><strong>create_normalized_heights(x, cdf)</strong></p></td>
<td><p>Use normalize function to create normalized heights in new PointData array.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>create_reflectance()</strong></p></td>
<td><p>Create reflectance field in polydata_raw according to RiSCAN instructs.</p></td>
</tr>
<tr class="row-even"><td><p><strong>create_reflectance_pipeline(v_min, v_max)</strong></p></td>
<td><p>create mapper and actor for displaying points with colors by reflectance</p></td>
</tr>
<tr class="row-odd"><td><p><strong>correct_reflectance_radial(mode)</strong></p></td>
<td><p>Adjust reflectance for radial artifact.</p></td>
</tr>
<tr class="row-even"><td><p><strong>reflectance_filter(threshold, radius=0, field=’reflectance_radial’)</strong></p></td>
<td><p>Set Classification values for high reflectance objects (and neighborhood if desired) to 66.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>write_npy_pdal(output_dir, filename, mode)</strong></p></td>
<td><p>Write SingleScan to numpy structured array that can be read by pdal.</p></td>
</tr>
<tr class="row-even"><td><p><strong>write_pdal_transformation_json(mode, input_dir, output_dir)</strong></p></td>
<td><p>Write a JSON string for PDAL such that it transforms raw scan data by self.transform.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>create_dimensionality_pdal(temp_file=””, from_current=True, voxel=True,</strong></p></td>
<td><p>h_voxel=0.1, v_voxel=0.01, threads=8) Create the four dimensionality variables from Demantke2011 and Guinard2017. Uses pdal to do so.</p></td>
</tr>
<tr class="row-even"><td><p><strong>create_heightaboveground_pdal(resolution=1, temp_file=””,</strong></p></td>
<td><p>from_current=True, voxel=True, h_voxel=0.1, v_voxel=0.1) Create height above ground value for each point in scan. To start we’ll just rasterize all points but we may eventually add csf filter.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>add_dist()</strong></p></td>
<td><p>Add distance from scanner to polydata_raw</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.add_dist">
<span class="sig-name descname"><span class="pre">add_dist</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.add_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Add distance array to polydata_raw</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.add_sop">
<span class="sig-name descname"><span class="pre">add_sop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.add_sop" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the sop matrix to transform_dict. Must have exported from RiSCAN</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.add_transform">
<span class="sig-name descname"><span class="pre">add_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">history_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.add_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a new transform to the transform_dict</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>key</strong><span class="classifier">str</span></dt><dd><p>Name of the tranform (e.g. ‘sop’)</p>
</dd>
<dt><strong>matrix</strong><span class="classifier">4x4 array-like</span></dt><dd><p>4x4 matrix of transformation in homologous coordinates.</p>
</dd>
<dt><strong>history_dict</strong><span class="classifier">dict</span></dt><dd><p>dict tree containing history of transform. If None then we create
a Transform Source node with the matrix as a param. The default
is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.add_z_offset">
<span class="sig-name descname"><span class="pre">add_z_offset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z_offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">history_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.add_z_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a uniform z offset to the scan</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z_offset</strong><span class="classifier">float</span></dt><dd><p>z offset to add in meters.</p>
</dd>
<dt><strong>history_dict</strong><span class="classifier">dict</span></dt><dd><p>dict tree containing history of transform. If None then we create
a Transform Source node with the z_offset as a param. If the z
offset was computed from an upstream source (like ScanArea.z_align
) then that information should be passed in in history_dict.
The default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.apply_elevation_filter">
<span class="sig-name descname"><span class="pre">apply_elevation_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z_max</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.apply_elevation_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Set Classification for all points above z_max to be 64.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z_max</strong><span class="classifier">float</span></dt><dd><p>Maximum z-value (in reference frame of currentTransform).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.apply_man_class">
<span class="sig-name descname"><span class="pre">apply_man_class</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.apply_man_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the classification of manually classified points in polydata_raw</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.apply_manual_filter">
<span class="sig-name descname"><span class="pre">apply_manual_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">corner_coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.0,</span> <span class="pre">0.0,</span> <span class="pre">1.0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">category</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">73</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'currentFilter'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.apply_manual_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Manually classify points using a selection loop.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>corner_coords</strong><span class="classifier">ndarray</span></dt><dd><p>Nx3 array of points defining corners of selection.</p>
</dd>
<dt><strong>normal</strong><span class="classifier">array-like, optional</span></dt><dd><p>Three element vector describing normal (axis) of loop. 
The default is (0, 0, 1).</p>
</dd>
<dt><strong>category</strong><span class="classifier">uint8, optional</span></dt><dd><p>Which category to classify points as. The default is 73.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>What to apply filter to. Options are ‘currentFilter’ and
‘transformFilter’. The default is ‘currentFilter’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.apply_rmin_filter">
<span class="sig-name descname"><span class="pre">apply_rmin_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">150000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.apply_rmin_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign all points very close to the scanner as snowflakes. This filter
is applied to the output of current filter (and hence depends on)
the current transform we have applied.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>buffer</strong><span class="classifier">float, optional</span></dt><dd><p>How far past the cylindrical shell defined by count to go in m. 
The default is 0.05.</p>
</dd>
<dt><strong>count</strong><span class="classifier">int, optional</span></dt><dd><p>How many points to count before we decide that we’re at the edge.
The default is 150000</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.apply_snowflake_filter_2">
<span class="sig-name descname"><span class="pre">apply_snowflake_filter_2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z_diff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_min</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.apply_snowflake_filter_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter snowflakes based on their vertical distance from nearby points.</p>
<p>Here we exploit the fact that snowflakes (and for that matter power
cables and some other human objects) are higher than their nearby
points. The filter steps through each point in the transformed
dataset and compares its z value with the mean of the z-values of
the N closest points. If the difference exceeds z_diff then set the
Classification for that point to be 2. Also, there is a shadow around the
base of the scanner so all points within there must be spurious. We
filter all points within r_min</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z_diff</strong><span class="classifier">float</span></dt><dd><p>Maximum vertical difference in m a point can have from its 
neighborhood.</p>
</dd>
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of neighbors to find.</p>
</dd>
<dt><strong>r_min</strong><span class="classifier">float</span></dt><dd><p>Radius of scanner in m within which to filter all points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.apply_snowflake_filter_3">
<span class="sig-name descname"><span class="pre">apply_snowflake_filter_3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z_std_mult</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leafsize</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.apply_snowflake_filter_3" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter points as snowflakes based on whether their z value in the
transformed reference frame exceeds z_std_mult multiples of the mean
z values for points nearby (within a bucket of size leafsize).</p>
<p>We apply this only to the output of currentFilter!</p>
<p>All points that this filter identifies as snowflakes are set to
Classification=65</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z_std_mult</strong><span class="classifier">float</span></dt><dd><p>The number of positive z standard deviations greater than other
nearby points for us to classify it as a snowflake.</p>
</dd>
<dt><strong>leafsize</strong><span class="classifier">int</span></dt><dd><p>maximum number of points in each bucket (we use scipy’s
KDTree)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.apply_snowflake_filter_returnindex">
<span class="sig-name descname"><span class="pre">apply_snowflake_filter_returnindex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cylinder_rad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0006170670747442177</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radial_precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.apply_snowflake_filter_returnindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter snowflakes using return index visible space.</p>
<p>Snowflakes are too small to fully occlude the laser pulse. Therefore
all snowflakes will be one of multiple returns (returnindex&lt;-1).
However, the edges of shadows will also be one of multiple returns. To
address this we look at each early return and check if it’s on the 
border of the visible area from the scanner’s perspective. We do this
by finding all points within cylinder_rad of the point in question
in panorama space. Then, if the radial value of the point in question
is greater than any of these radial values that means the point
in question is on the border of the visible region and we should keep
it.</p>
<p>All points that this filter identifies as snowflakes are set to
Classification=65</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cylinder_rad</strong><span class="classifier">float, optional</span></dt><dd><p>The radius of a cylinder, in radians around an early return
to look for last returns. The default is 0.025*np.sqrt(2)*np.pi/
180.</p>
</dd>
<dt><strong>radial_precision</strong><span class="classifier">float, optional</span></dt><dd><p>If an early return’s radius is within radial_precision of an
adjacent last return accept it as surface. The default is 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.apply_transforms">
<span class="sig-name descname"><span class="pre">apply_transforms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transform_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.apply_transforms" title="Permalink to this definition">¶</a></dt>
<dd><p>Update transform to be a concatenation of transform_list.</p>
<p>Clears existing transform!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>transform_list</strong><span class="classifier">list</span></dt><dd><p>str in list must be keys in transform_dict. Transformations are 
applied in the same order as in the list (postmultiply order)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.clear_classification">
<span class="sig-name descname"><span class="pre">clear_classification</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.clear_classification" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset Classification for all points to 0</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.correct_reflectance_radial">
<span class="sig-name descname"><span class="pre">correct_reflectance_radial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.correct_reflectance_radial" title="Permalink to this definition">¶</a></dt>
<dd><p>Corrects radial artifact in reflectance. result: ‘reflectance_radial’</p>
<p>Attempts to correct radial artifact in reflectance. Still developing
the best way to do this.</p>
<p>If mode is ‘median’: bin the raw reflectances by radial distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mode</strong><span class="classifier">str</span></dt><dd><p>Method for correcting radial artifact in reflectances. Currently
only coded for ‘median’.</p>
</dd>
<dt><strong>r_min</strong><span class="classifier">float, optional</span></dt><dd><p>Needed for method ‘median’ minimum radius to bin</p>
</dd>
<dt><strong>r_max</strong><span class="classifier">float, optional</span></dt><dd><p>Needed for method ‘median’ maximum radius to bin</p>
</dd>
<dt><strong>num</strong><span class="classifier">int, optional</span></dt><dd><p>Needed for method ‘median’, number of bins</p>
</dd>
<dt><strong>base</strong><span class="classifier">float, optional</span></dt><dd><p>Needed for method ‘median’, base for logspaced bins</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.create_dimensionality_pdal">
<span class="sig-name descname"><span class="pre">create_dimensionality_pdal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">temp_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_current</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h_voxel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_voxel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.create_dimensionality_pdal" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses pdal functions to voxel downsample and create dimensionality
variables from Demantke2011 and Guinard2017.</p>
<p>WARNING: This method replaces polydata_raw but does not modify
transforms</p>
<p>If from_current, we write the current polydata-points with 
Classification of 0, 1, or 2 and transformed by the current transform-
to a pdal readable numpy file in temp_file. We then create a json
with the instructions to voxelize that data, run 
filters.optimalneighborhood and filters.covariancefeatures and make
the results available as numpy arrays. Finally, we replace the points
in polydata_raw with the matching PointId’s and eliminate other points
in polydata_raw.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>temp_file</strong><span class="classifier">str, optional</span></dt><dd><p>Location to write numpy file to. If “” use self.project_path +
‘temptemp_pdal.npy’. The default is “”.</p>
</dd>
<dt><strong>from_current</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to write the current polydata to file, if False will use
whichever file is currently in the temp directory. False should 
only be used for debugging. The default is True.</p>
</dd>
<dt><strong>voxel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to voxel nearest centroid downsample. The default is True.</p>
</dd>
<dt><strong>h_voxel</strong><span class="classifier">float, optional</span></dt><dd><p>Horizontal voxel dimension in m. The default is 0.1.</p>
</dd>
<dt><strong>v_voxel</strong><span class="classifier">float, optional</span></dt><dd><p>Vertical voxel dimension in m. The default is 0.01.</p>
</dd>
<dt><strong>threads</strong><span class="classifier">int, optional</span></dt><dd><p>Number of threads to use in covariancefeatures</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.create_elevation_pipeline">
<span class="sig-name descname"><span class="pre">create_elevation_pipeline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">LOD</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.create_elevation_pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>create mapper and actor displaying points colored by elevation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z_min</strong><span class="classifier">float</span></dt><dd><p>Lower cutoff for plotting colors.</p>
</dd>
<dt><strong>z_max</strong><span class="classifier">float</span></dt><dd><p>Upper cutoff for plotting colors.</p>
</dd>
<dt><strong>lower_threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Minimum elevation of point to display. The default is -1000.</p>
</dd>
<dt><strong>upper_threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Maximum elevation of point to display. The default is 1000.</p>
</dd>
<dt><strong>LOD</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to generate a level of detail actor. The default is True</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.create_filter_pipeline">
<span class="sig-name descname"><span class="pre">create_filter_pipeline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{0:</span> <span class="pre">(0.6,</span> <span class="pre">0.6,</span> <span class="pre">0.6,</span> <span class="pre">1),</span> <span class="pre">1:</span> <span class="pre">(0.6,</span> <span class="pre">0.6,</span> <span class="pre">0.6,</span> <span class="pre">1),</span> <span class="pre">2:</span> <span class="pre">(0.21568627450980393,</span> <span class="pre">0.49411764705882355,</span> <span class="pre">0.7215686274509804,</span> <span class="pre">1),</span> <span class="pre">6:</span> <span class="pre">(0.6509803921568628,</span> <span class="pre">0.33725490196078434,</span> <span class="pre">0.1568627450980392,</span> <span class="pre">1),</span> <span class="pre">7:</span> <span class="pre">(1.0,</span> <span class="pre">1.0,</span> <span class="pre">0.2,</span> <span class="pre">1),</span> <span class="pre">64:</span> <span class="pre">(1.0,</span> <span class="pre">1.0,</span> <span class="pre">0.2,</span> <span class="pre">1),</span> <span class="pre">65:</span> <span class="pre">(1.0,</span> <span class="pre">1.0,</span> <span class="pre">0.2,</span> <span class="pre">1),</span> <span class="pre">66:</span> <span class="pre">(1.0,</span> <span class="pre">1.0,</span> <span class="pre">0.2,</span> <span class="pre">1),</span> <span class="pre">67:</span> <span class="pre">(0.8941176470588236,</span> <span class="pre">0.10196078431372549,</span> <span class="pre">0.10980392156862745,</span> <span class="pre">1),</span> <span class="pre">68:</span> <span class="pre">(0.30196078431372547,</span> <span class="pre">0.6862745098039216,</span> <span class="pre">0.2901960784313726,</span> <span class="pre">1),</span> <span class="pre">69:</span> <span class="pre">(0.9686274509803922,</span> <span class="pre">0.5058823529411764,</span> <span class="pre">0.7490196078431373,</span> <span class="pre">1),</span> <span class="pre">70:</span> <span class="pre">(0.596078431372549,</span> <span class="pre">0.3058823529411765,</span> <span class="pre">0.6392156862745098,</span> <span class="pre">1),</span> <span class="pre">71:</span> <span class="pre">(1.0,</span> <span class="pre">0.4980392156862745,</span> <span class="pre">0.0,</span> <span class="pre">1),</span> <span class="pre">72:</span> <span class="pre">(0.9921568627450981,</span> <span class="pre">0.7490196078431373,</span> <span class="pre">0.43529411764705883,</span> <span class="pre">1),</span> <span class="pre">73:</span> <span class="pre">(1.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0,</span> <span class="pre">1)}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.create_filter_pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Create mapper and actor displaying points colored by Classification</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>colors</strong><span class="classifier">dict, optional</span></dt><dd><p>Mapping from value in Classification to color. 
The default is {0 : (0, 255, 0), 1 : (255, 0, 0)}.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.create_heightaboveground_pdal">
<span class="sig-name descname"><span class="pre">create_heightaboveground_pdal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">temp_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temp_file_tif</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_current</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">create_dem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.create_heightaboveground_pdal" title="Permalink to this definition">¶</a></dt>
<dd><p>Create height above ground value for each point in scan.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>resolution</strong><span class="classifier">float, optional</span></dt><dd><p>DEM resolution in m. The default is 1.</p>
</dd>
<dt><strong>temp_file</strong><span class="classifier">str, optional</span></dt><dd><p>Location to write numpy file to. If “” use self.project_path +
‘temptemp_pdal.npy’. The default is “”.</p>
</dd>
<dt><strong>temp_file_tif</strong><span class="classifier">str, optional</span></dt><dd><p>tempfile for storing dem, if “” defaults to temp_dir/project_name
_scan_name.tif. The default is “”.</p>
</dd>
<dt><strong>from_current</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to write the current polydata to file, if False will use
whichever file is currently in the temp directory. False should 
only be used for debugging. The default is True.</p>
</dd>
<dt><strong>create_dem</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to create a dem from this SingleScan. If not you should
probably supply a temp_file_tif string to this function. The 
default is True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.create_normalized_heights">
<span class="sig-name descname"><span class="pre">create_normalized_heights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cdf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.create_normalized_heights" title="Permalink to this definition">¶</a></dt>
<dd><p>Use normalize function to create normalized heights in new PointData
array.</p>
<p>Here we use the normalize function (defined below in Pydar) to
transform the z values from the output of transformFilter to a normal
distribution assuming they were drawn from the distribution specified
by x and cdf.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">1d-array</span></dt><dd><p>Bin values in empirical cdf.</p>
</dd>
<dt><strong>cdf</strong><span class="classifier">1d-array</span></dt><dd><p>Values of empirical cdf.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.create_normals">
<span class="sig-name descname"><span class="pre">create_normals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.create_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Open3d to compute pointwise normals and store.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">float, optional</span></dt><dd><p>Max distance to look for nearby points. The default is 2.</p>
</dd>
<dt><strong>max_nn</strong><span class="classifier">int, optional</span></dt><dd><p>max number of points to use in normal estimation. 
The default is 30.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.create_reflectance">
<span class="sig-name descname"><span class="pre">create_reflectance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.create_reflectance" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Reflectance field in polydata_raw according to RiSCAN instructs.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.create_reflectance_pipeline">
<span class="sig-name descname"><span class="pre">create_reflectance_pipeline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Reflectance'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.create_reflectance_pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>create mapper and actor displaying points colored by elevation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v_min</strong><span class="classifier">float</span></dt><dd><p>Lower cutoff for plotting colors.</p>
</dd>
<dt><strong>v_max</strong><span class="classifier">float</span></dt><dd><p>Upper cutoff for plotting colors.</p>
</dd>
<dt><strong>field</strong><span class="classifier">str, optional</span></dt><dd><p>Which array in pointdata to display. The default is ‘Reflectance’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.create_scanner_actor">
<span class="sig-name descname"><span class="pre">create_scanner_actor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Gray'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">150</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.create_scanner_actor" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an actor for visualizing the scanner and its orientation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.create_solid_pipeline">
<span class="sig-name descname"><span class="pre">create_solid_pipeline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Green'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.create_solid_pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Create vtk visualization pipeline with solid colors</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>color</strong><span class="classifier">string, optional</span></dt><dd><p>Name of color (in vtkNamedColors). The default is ‘Green’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.create_z_sigma">
<span class="sig-name descname"><span class="pre">create_z_sigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma_ro</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.008</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_bw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">7.5e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.create_z_sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the pointwise uncertainty in the z-direction.</p>
<p>For each point, project the pointwise uncertainty spheroid onto the z 
unit vector in the reference frame defined by the current transform.</p>
<p>Each point measured by the scanner has a positional uncertainty that
can be described as a gaussian spheroid. The symmetry axis of this
spheroid is aligned with the direction of the laser beam, which we
will name p_hat. Along p_hat the uncertainty is determined by the
ranging uncertainty of the laser (sigma_ro). Perpendicular to p_hat
in all directions, our uncertainty is due to the bandwidth spreading
of the laser beam–sigma_bw. sigma_bw is measured in radians and to 
get sigma_b measured in m we need to multiply by the distance.</p>
<p>In order to find the uncertainty in the z direction of the current
transform, we first project the z unit vector in the current 
transform’s reference frame into the scanner’s reference 
frame–z_prime. Then we use the dot product of z_prime with p_hat for
each point to get the cosine of the angle between them. Finally,
the distance from the origin of the uncertainty spheroid to the 1
sigma surface along the direction z_prime can be computed from the
squared cosine of the angle between z_prime and p_hat.</p>
<p>Finally, we save the result as an array in polydata_raw.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sigma_ro</strong><span class="classifier">float, optional</span></dt><dd><p>The standard deviation of the laser’s ranging uncertainty in m.
The default is 0.008 (value for VZ-1000)</p>
</dd>
<dt><strong>sigma_bw</strong><span class="classifier">float, optional</span></dt><dd><p>The standard deviation of the laser’s bandwidth spreading in
radians. The defaults is 0.0003/4 (value for VZ-1000)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.get_polydata">
<span class="sig-name descname"><span class="pre">get_polydata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">history_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.get_polydata" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vtkPolyData of scan with current transforms and filters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>port</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to return an output connection instead of a polydata.
The default is False</p>
</dd>
<dt><strong>history_dict</strong><span class="classifier">bool, optional</span></dt><dd><p>If history, also return the history dict for this polydata. The
default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>vtkPolyData or vtkAlgorithmOutput.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.load_man_class">
<span class="sig-name descname"><span class="pre">load_man_class</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.load_man_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the man_class dataframe. Create if it does not exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.random_voxel_downsample_filter">
<span class="sig-name descname"><span class="pre">random_voxel_downsample_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1234</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.random_voxel_downsample_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Downsample point cloud with one random point per voxel.</p>
<p>This filter takes, as input, the current transformed, filtered
polydata.</p>
<p>Executing this will overwrite polydata_raw!!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>wx</strong><span class="classifier">float</span></dt><dd><p>Voxel x dimension in m.</p>
</dd>
<dt><strong>wy</strong><span class="classifier">float</span></dt><dd><p>Voxel y dimension in m.</p>
</dd>
<dt><strong>wz</strong><span class="classifier">float, optional</span></dt><dd><p>Voxel z dimension in m. If none then we just downsample
horizontally. The default is None.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random seed for the shuffler. The default is 1234.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.read_scan">
<span class="sig-name descname"><span class="pre">read_scan</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.read_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads a scan from a vtp file</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.read_transform">
<span class="sig-name descname"><span class="pre">read_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">read_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'current_transform'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.read_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the requested transform (if it exists)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>read_dir</strong><span class="classifier">str, optional</span></dt><dd><p>Path to read transform from. If None read from /project_path/
project_name/transforms/scan_name/. The default is None.</p>
</dd>
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>Name of the transform to read. The default is ‘current_transform’.</p>
</dd>
<dt><strong>suffix</strong><span class="classifier">str, optional</span></dt><dd><p>Suffix for transforms directory if we are reading scans. 
The default is ‘’ which corresponds to the regular transforms 
directory.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.reflectance_filter">
<span class="sig-name descname"><span class="pre">reflectance_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflectance_radial'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.reflectance_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Set Classification values for high reflectance objects (and neighborhood
if desired) to 66.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>reflectance threshold above which to flag</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float, optional</span></dt><dd><p>Radius around flagged points to also flag. The default is 0.</p>
</dd>
<dt><strong>field</strong><span class="classifier">str, optional</span></dt><dd><p>The field in PointData to threshold. The default is 
‘reflectance_radial’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.update_current_filter">
<span class="sig-name descname"><span class="pre">update_current_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.update_current_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the current filter to the new class list</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>class_list</strong><span class="classifier">list</span></dt><dd><p>List of categories this filter will return, if special value: 
‘all’ Then we do not have a selection filter and we pass through 
all points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.update_man_class">
<span class="sig-name descname"><span class="pre">update_man_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pdata</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classification</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.update_man_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the points in man_class with the points in pdata.</p>
<p>See documentation under SingleScan for description of man_class</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pdata</strong><span class="classifier">vtkPolyData</span></dt><dd><p>PolyData containing the points to add to man_class.</p>
</dd>
<dt><strong>classification</strong><span class="classifier">uint8</span></dt><dd><p>The classification code of the points. See SingleScan 
documentation for mapping from code to text</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.update_man_class_fields">
<span class="sig-name descname"><span class="pre">update_man_class_fields</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">update_fields</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update_trans</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.update_man_class_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Update man_class table with the fields that are currently in
polydata_raw.</p>
<p>Requires that PointId’s haven’t changed!!!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>update_fields</strong><span class="classifier">list or ‘all’, optional</span></dt><dd><p>Which fields in man_class we want to update. If ‘all’ update all 
but Classification. The default is ‘all’.</p>
</dd>
<dt><strong>update_trans</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to update the transformation matrix values with the
current transformation. The default is True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.write_current_transform">
<span class="sig-name descname"><span class="pre">write_current_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">write_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'current_transform'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rigid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.write_current_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the current tranform and its history_dict to files.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>write_dir</strong><span class="classifier">str, optional</span></dt><dd><p>The path where to write the transform. If None we’ll write to 
project_path/project_name/transforms/scan_name. The default is 
None.</p>
</dd>
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>The name to give the output files. The default is 
‘current_transform’.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>What type of transformation it is. Currently the only option is
‘rigid’ (6 components). The default is ‘rigid’.</p>
</dd>
<dt><strong>suffix</strong><span class="classifier">str, optional</span></dt><dd><p>Suffix for transforms directory if we are reading scans. 
The default is ‘’ which corresponds to the regular transforms
directory.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.write_npy_pdal">
<span class="sig-name descname"><span class="pre">write_npy_pdal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'transformed'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_fields</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.write_npy_pdal" title="Permalink to this definition">¶</a></dt>
<dd><p>Write scan to structured numpy array that can be read by PDAL.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>output_dir</strong><span class="classifier">str, optional</span></dt><dd><p>Directory to write to. If none will write to the ‘temp’ folder
under the project name.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str, optional</span></dt><dd><p>Filename to write, if None will write PROJECT_NAME_SCAN_NAME. 
The default is None.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>Whether to write ‘raw’ points, ‘transformed’ points, or ‘filtered’
points. The default is ‘transformed’.</p>
</dd>
<dt><strong>skip_fields</strong><span class="classifier">list, optional</span></dt><dd><p>Fields to skip in writing. If this is ‘all’ then only write x,
y, z. Otherwise should be a list of field names. The default is []</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.write_pdal_transformation_json">
<span class="sig-name descname"><span class="pre">write_pdal_transformation_json</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'las'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./pdal_output/'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.write_pdal_transformation_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Write pdal formatted JSON for transforming raw data to current.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>Datatype of the input. The default is ‘las’.</p>
</dd>
<dt><strong>input_dir</strong><span class="classifier">str, optional</span></dt><dd><p>Location to find file. The default is ‘./’.</p>
</dd>
<dt><strong>output_dir</strong><span class="classifier">TYPE, optional</span></dt><dd><p>Location to put pdal output. The default is ‘./pdal_output/’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.SingleScan.write_scan">
<span class="sig-name descname"><span class="pre">write_scan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">write_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.SingleScan.write_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the scan to a collection of numpy files.</p>
<p>This enables us to save the Classification field so we don’t need to 
run all of the filters each time we load data. Additionally, npy files
are much faster to load than vtk files. Finally, we need to write
the history_dict to this directory as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>write_dir: str, optional</strong></dt><dd><p>Directory to write scan files to. If None write default npyfiles
location. The default is None.</p>
</dd>
<dt><strong>class_list: list, optional</strong></dt><dd><p>Whether to first filter the data so that we only write points whose
Classification values are in class_list. If None do not filter.
The default is None.</p>
</dd>
<dt><strong>suffix: str, optional</strong></dt><dd><p>Suffix for writing to the correct npyfiles directory. The default
is ‘’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydar.TiePointList">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">TiePointList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.TiePointList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class to contain tiepointlist object and methods.</p>
<p>…</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>project_name</strong><span class="classifier">str</span></dt><dd><p>Filename of the RiSCAN project the tiepointlist comes from</p>
</dd>
<dt><strong>project_path</strong><span class="classifier">str</span></dt><dd><p>Directory location of the project.</p>
</dd>
<dt><strong>tiepoints</strong><span class="classifier">Pandas dataframe</span></dt><dd><p>List of tiepoint names and coordinates in project coordinate system.</p>
</dd>
<dt><strong>tiepoints_transformed</strong><span class="classifier">Pandas dataframe</span></dt><dd><p>List of tiepoints transformed into a new coordinate system.</p>
</dd>
<dt><strong>current_transform</strong><span class="classifier">tuple</span></dt><dd><p>Tuple with index of current transform (the one used to create 
tiepoints_transformed).</p>
</dd>
<dt><strong>pwdist</strong><span class="classifier">Pandas dataframe</span></dt><dd><p>List of unique pairwise distances between reflectors.</p>
</dd>
<dt><strong>dict_compare</strong><span class="classifier">dict</span></dt><dd><p>Stores comparisons of self pwdist with other tiepointlists’ pwdists.</p>
</dd>
<dt><strong>transforms</strong><span class="classifier">dict</span></dt><dd><p>Stores transformations that aligns self tiepoints with others. Keyed
on tuples (name, str_reflector_list). Each entry is a tuple 
(reflector_list, transform, std).</p>
</dd>
<dt><strong>raw_history_dict</strong><span class="classifier">dict</span></dt><dd><p>A dict containing the history of modification dependencies as a tree
see SingleScan docstring for more details</p>
</dd>
<dt><strong>transformed_history_dict</strong><span class="classifier">dict</span></dt><dd><p>Same as raw history dict for tiepoints_transformed</p>
</dd>
<dt><strong>trans_history_dict</strong><span class="classifier">dict</span></dt><dd><p>for each transformation in transforms gives the node of the history
tree keyed the same as in transforms</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>calc_pairwise_dist()</strong></p></td>
<td><p>Calculates the distances between each unique pair of reflectors.</p></td>
</tr>
<tr class="row-even"><td><p><strong>compare_pairwise_dist(other_tiepointlist)</strong></p></td>
<td><p>Compares pwdist with other_tiepointlist, stores result in compare_dict</p></td>
</tr>
<tr class="row-odd"><td><p><strong>plot_map(other_project_name, delaunay=False, mode=’dist’)</strong></p></td>
<td><p>Plots a map of the change in reflector distances.</p></td>
</tr>
<tr class="row-even"><td><p><strong>calc_transformation(other_tiepointlist, reflector_list, mode=’LS’)</strong></p></td>
<td><p>Calculates best fitting rigid transformation to align with other.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>add_transform(name, transform, reflector_list=[], std=np.NaN)</strong></p></td>
<td><p>Adds a transform the the transforms dataframe.</p></td>
</tr>
<tr class="row-even"><td><p><strong>apply_transform(index)</strong></p></td>
<td><p>Applies a transform in transforms to update tiepoints_transformed.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>get_transform(index)</strong></p></td>
<td><p>Returns the requested numpy array.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="pydar.TiePointList.add_transform">
<span class="sig-name descname"><span class="pre">add_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reflector_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">history_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.TiePointList.add_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a transform to the transforms dict.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>The name of the tranformation to put in self.transforms</p>
</dd>
<dt><strong>transform</strong><span class="classifier">4x4 ndarray</span></dt><dd><p>The affine transformation in homologous coordinates.</p>
</dd>
<dt><strong>reflector_list</strong><span class="classifier">list, optional</span></dt><dd><p>List of reflectors used to find this transformation (if any). 
The default is None.</p>
</dd>
<dt><strong>std</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation of residuals between aligned reflectors in m
if transformation is from reflectors. The default is None.</p>
</dd>
<dt><strong>history_dict</strong><span class="classifier">dict</span></dt><dd><p>dict tree containing history of transform. If None then we create
a Transform Source node with the matrix as a param. The default
is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>key</strong><span class="classifier">tuple</span></dt><dd><p>The tuple that the tranform is keyed (indexed) in on transforms.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.TiePointList.apply_transform">
<span class="sig-name descname"><span class="pre">apply_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.TiePointList.apply_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the transform in transforms to update tiepoints_transformed</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">tuple</span></dt><dd><p>Index of the transform in self.transforms to apply</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.TiePointList.calc_pairwise_dist">
<span class="sig-name descname"><span class="pre">calc_pairwise_dist</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.TiePointList.calc_pairwise_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the pairwise distances between each unique pair of 
reflectors</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.TiePointList.calc_transformation">
<span class="sig-name descname"><span class="pre">calc_transformation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other_tiepointlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reflector_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'LS'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_tiepoints_transformed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yaw_angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.TiePointList.calc_transformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the rigid transformation to align with other tiepointlist.</p>
<p>See info under mode. In either mode, we start by computing the 
centroids of the selected reflectors in both lists and create arrays
of position relative to centroid. Then we use the singular value
decomposition to find the rotation matrix (either in 3 dimensions or
1 depending on mode) that best aligns the reflectors. Finally, we 
solve for the appropriate translation based on the centroids. We store
the result as a 4x4 matrix in self.transforms.</p>
<dl class="simple">
<dt>The method used here is based off of Arun et al 1987:</dt><dd><p><a class="reference external" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4767965">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4767965</a></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other_tiepointlist</strong><span class="classifier">TiePointList</span></dt><dd><p>TiePointList to compare with.</p>
</dd>
<dt><strong>reflector_list</strong><span class="classifier">list</span></dt><dd><p>List of tiepoints to align.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>Mode of the transformation, in ‘LS’ transformation can rotate on 
all 3 axes to find best fit (must have at least 3 reflectors). In
‘Yaw’ the z axis is fixed and we are only rotating around it (it 
still translates in all 3 dimensions). The default is ‘LS’.</p>
</dd>
<dt><strong>use_tiepoints_transformed</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to use the tiepoints_transformed from the other tiepoint
list or the raw ones. The default is True.</p>
</dd>
<dt><strong>yaw_angle</strong><span class="classifier">float, optional</span></dt><dd><p>If the mode is ‘Trans’ this is the angle (in radians) by which to
change the heading of the scan. The default is 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>key</strong><span class="classifier">tuple</span></dt><dd><p>The tuple that the tranform is keyed (indexed) in on transforms.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.TiePointList.compare_pairwise_dist">
<span class="sig-name descname"><span class="pre">compare_pairwise_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other_tiepointlist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.TiePointList.compare_pairwise_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares pairwise distances of TiePointList with the other one and 
stores results in a dictionary whose key is the name of the other.</p>
<p>Note, our typical usage will be to compare the current tiepointlist
with one from a week prior. Thus the difference we calculate is this
list’s distance minus the other distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other_tiepointlist</strong><span class="classifier">TiePointList to compare to.</span></dt><dd><p>These tiepoints will be represented by rB and dist_y.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None. But stores results in a dictionary. Keyed on name of other.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.TiePointList.get_transform">
<span class="sig-name descname"><span class="pre">get_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">history_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.TiePointList.get_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the requested transform’s array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">tuple</span></dt><dd><p>Key for desired transform in self.transforms.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray or (ndarray, dict)</dt><dd><p>ndarray is 4x4 matrix of the requested transform. dict is the
transform’s history_dict</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydar.TiePointList.plot_map">
<span class="sig-name descname"><span class="pre">plot_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other_project_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delaunay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dist'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_tiepoints_transformed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.TiePointList.plot_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot lines showing change in distances or strains between two scans.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other_project_name</strong><span class="classifier">str</span></dt><dd><p>Other project must already be in dict_compare.</p>
</dd>
<dt><strong>delaunay</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to plot just the lines that are part of the Delaunay 
triangulation. The default is False.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>If ‘dist’ display differences as distances, if ‘strain’ display 
differences as strains. The default is ‘dist’.</p>
</dd>
<dt><strong>use_tiepoints_transformed</strong><span class="classifier">bool, optional</span></dt><dd><p>If true plot tiepoints at locations given by tiepoints_transformed.
The default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Matplotlib figure and axes objects.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.biquad_difference_plot">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">biquad_difference_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arr0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arr1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.biquad_difference_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots difference of 2 2D arrays that are fourier indexed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ax</strong><span class="classifier">matplotlib.pyplot.axis</span></dt><dd><p>axis object to plot on</p>
</dd>
<dt><strong>arr0</strong><span class="classifier">2D array</span></dt><dd><p>array to difference, can be either full or biquad</p>
</dd>
<dt><strong>arr1</strong><span class="classifier">2d array</span></dt><dd><p>array to difference, can be either full or biquad</p>
</dd>
<dt><strong>bins_0</strong><span class="classifier">int</span></dt><dd><p>number of positive and negative freqency bins along zeroth axis to 
show</p>
</dd>
<dt><strong>bins_1</strong><span class="classifier">int</span></dt><dd><p>number of positive bins along first axis</p>
</dd>
<dt><strong>dx0</strong><span class="classifier">float, optional</span></dt><dd><p>pixel length along axis 0. The default is 1.</p>
</dd>
<dt><strong>dx1</strong><span class="classifier">float, optional</span></dt><dd><p>pixel length along axis 1. The default is 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>pyplot mappable</dt><dd><p>plot object to generate colorbar with</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.biquad_plot">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">biquad_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'inverse'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.biquad_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots center of a 2D array that is fourier indexed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ax</strong><span class="classifier">matplotlib.pyplot.axis</span></dt><dd><p>axis object to plot on</p>
</dd>
<dt><strong>arr</strong><span class="classifier">2D array</span></dt><dd><p>array to plot, can be either full or biquad</p>
</dd>
<dt><strong>bins_0</strong><span class="classifier">int</span></dt><dd><p>number of positive and negative bins along zeroth axis to 
show</p>
</dd>
<dt><strong>bins_1</strong><span class="classifier">int</span></dt><dd><p>number of positive bins along first axis</p>
</dd>
<dt><strong>dx0</strong><span class="classifier">float, optional</span></dt><dd><p>pixel length along axis 0. The default is 1.</p>
</dd>
<dt><strong>dx1</strong><span class="classifier">float, optional</span></dt><dd><p>pixel length along axis 1. The default is 1.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>Which mode for bin units. The default is ‘inverse’</p>
</dd>
<dt><strong>vmin, vmax</strong><span class="classifier">float, optional</span></dt><dd><p>Limits for color plotting. The default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>pyplot mappable</dt><dd><p>plot object to generate colorbar with</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.block_circ_base">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">block_circ_base</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.block_circ_base" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a block circulant base with parameters given by theta</p>
<p>See Rue and Held 2005. p. 196</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n0</strong><span class="classifier">int</span></dt><dd><p>Size of the domain in the row direction.</p>
</dd>
<dt><strong>n1</strong><span class="classifier">int</span></dt><dd><p>Size of the domain in the column direction.</p>
</dd>
<dt><strong>m</strong><span class="classifier">int</span></dt><dd><p>Usually 2 or 3, half width of neighborhood.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">1d-array</span></dt><dd><p>Parameter values of precision matrix, ordered in the same manner as 
Rue and Held 2005 p. 196.</p>
</dd>
<dt><strong>c</strong><span class="classifier">ndarray, optional</span></dt><dd><p>If given, this is the array to place the block cirulant base into.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>n0xn1 array or none.</dt><dd><p>If c is not given then return block circulant base. If c is given 
modify in-place and don’t return anything.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.fit_theta_to_ro">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">fit_theta_to_ro</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ro</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.fit_theta_to_ro" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits parameters of GMRF precision matrix Q to given correlation matrix ro.</p>
<p>Assumes we want unit marginal variance. See Rue and Held 2005, ch. 5 for
details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ro</strong><span class="classifier">array</span></dt><dd><p>Target autocorrelation function. Same size as domain we’ll simulate</p>
</dd>
<dt><strong>wts</strong><span class="classifier">array</span></dt><dd><p>Weights to use for loss function. Same size as ro.</p>
</dd>
<dt><strong>p</strong><span class="classifier">float</span></dt><dd><p>Guess at range parameter, used in starting point of optimization</p>
</dd>
<dt><strong>m</strong><span class="classifier">int, optional</span></dt><dd><p>Size of the neighborhood to use in GMRF. The default is 2.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>theta1, theta</dt><dd><p>Tuple with theta1 scaling factor and theta neighbor weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.get_git_hash">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">get_git_hash</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydar.get_git_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current git hash string for pydar</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>str</dt><dd><p>The git hash string for the pydar repository</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.get_man_class">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">get_man_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_tuples</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.get_man_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dataframe with all of the requested manual classifications.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>project_tuples</strong><span class="classifier">list</span></dt><dd><p>List of tuples (project_path, project_name) to try loading manual
classifications from.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>pandas dataframe of manual classifications.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.gridded_counts_means">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">gridded_counts_means</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.gridded_counts_means" title="Permalink to this definition">¶</a></dt>
<dd><p>Grids a point cloud in x and y and returns the cellwise counts and mean z</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">float[:, :]</span></dt><dd><p>Pointcloud, Nx3 array of type np.float32</p>
</dd>
<dt><strong>edges</strong><span class="classifier">list</span></dt><dd><p>2 item list containing edges for gridding</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.gridded_counts_mins">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">gridded_counts_mins</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.gridded_counts_mins" title="Permalink to this definition">¶</a></dt>
<dd><p>Grids a point cloud in x and y and returns the cellwise counts and min z</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">float[:, :]</span></dt><dd><p>Pointcloud, Nx3 array of type np.float32</p>
</dd>
<dt><strong>edges</strong><span class="classifier">list</span></dt><dd><p>2 item list containing edges for gridding</p>
</dd>
<dt><strong>init_val</strong><span class="classifier">float</span></dt><dd><p>Initial values in mins array. Pick something larger than largest z
in Points. In mins output, all bins that don’t have any points in them
will take on this value.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.gridded_counts_modes">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">gridded_counts_modes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dz_hist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.gridded_counts_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Grids a point cloud in x and y and returns the cellwise counts and mode z</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">float[:, :]</span></dt><dd><p>Pointcloud, Nx3 array of type np.float32</p>
</dd>
<dt><strong>edges</strong><span class="classifier">list</span></dt><dd><p>2 item list containing edges for gridding</p>
</dd>
<dt><strong>dz_hist</strong><span class="classifier">float, optional</span></dt><dd><p>Bin width, in m for the z histogram (resolution of modal values)
The default is 0.01.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.gridded_max_ind">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">gridded_max_ind</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.gridded_max_ind" title="Permalink to this definition">¶</a></dt>
<dd><p>Grids a point cloud in x and y and returns the cellwise index of the point
within that cell with the max z.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">float[:, :]</span></dt><dd><p>Pointcloud, Nx3 array of type np.float32</p>
</dd>
<dt><strong>edges</strong><span class="classifier">list</span></dt><dd><p>2 item list containing edges for gridding</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.inormalize">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">inormalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cdf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.inormalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the inverse-cdf approach to transform normal data to an empirical dist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>yy</strong><span class="classifier">ndarray</span></dt><dd><p>The normally distributed data to transform.</p>
</dd>
<dt><strong>x</strong><span class="classifier">1d-array</span></dt><dd><p>Bin values in empirical cdf.</p>
</dd>
<dt><strong>cdf</strong><span class="classifier">1d-array</span></dt><dd><p>Values of empirical cdf.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>The transformed data, same shape as yy.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.matern_semivariance">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">matern_semivariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.matern_semivariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the semivariance at lag h for C(0)=theta_1 and lengthscale theta_2</p>
<p>From Gelfand et al. Handbook of Spatial Statistics pg. 37</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.mosaic_date_parser">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">mosaic_date_parser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.mosaic_date_parser" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses the project name into a date.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>project_name</strong><span class="classifier">str</span></dt><dd><p>The project name as a string.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The date and time (for April 8 b)</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.mplcmap_to_vtkLUT">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">mplcmap_to_vtkLUT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rainbow'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_under</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fuchsia'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_over</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'white'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.mplcmap_to_vtkLUT" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a vtkLookupTable from a matplotlib colormap.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vmin</strong><span class="classifier">float</span></dt><dd><p>Minimum value for colormap.</p>
</dd>
<dt><strong>vmax</strong><span class="classifier">float</span></dt><dd><p>Maximum value for colormap.</p>
</dd>
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>Matplotlib name of the colormap. The default is ‘rainbow’</p>
</dd>
<dt><strong>N</strong><span class="classifier">int, optional</span></dt><dd><p>Number of levels in colormap. The default is 256.</p>
</dd>
<dt><strong>color_under</strong><span class="classifier">str, optional</span></dt><dd><p>Color for values less than vmin, should be in vtkNamedColors. 
The default is ‘fuchsia’.</p>
</dd>
<dt><strong>color_over</strong><span class="classifier">str, optional</span></dt><dd><p>Color for values greater than vmax, should be in vtkNamedColors. 
The default is ‘white’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>vtkLookupTable</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.normalize">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cdf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the inverse-cdf approach to transform a dataset to normal distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xx</strong><span class="classifier">ndarray</span></dt><dd><p>The data to transform (should be in empirical distribution).</p>
</dd>
<dt><strong>x</strong><span class="classifier">1d-array</span></dt><dd><p>Bin values in empirical cdf.</p>
</dd>
<dt><strong>cdf</strong><span class="classifier">1d-array</span></dt><dd><p>Values of empirical cdf.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>The gaussian transformed data, same shape as xx.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.objective_fun">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">objective_fun</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.objective_fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements objective function for misfit of GMRF from GF.</p>
<p>See Rue and Held 2005, pg 197 eqn 5.10. This objective function returns
the weighted 2 norm between ro (the correlation of the desired GF) and
ro(theta) the correlation function of the GMRF approximation parameterized
by theta</p>
<p>!!! Note that Rue and Held use orthonormalized DFT !!!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta</strong><span class="classifier">1d array</span></dt><dd><p>Parameters for GMRF, see block_circ_base.</p>
</dd>
<dt><strong>args</strong><span class="classifier">tuple</span></dt><dd><p>Tuple with necessary arguments: (ro, w) where ro is the target
correlation function and w is an array of weights (same size as ro)
The size of ro and w is the same that will be used for GMRF base.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd><p>Weighted 2-norm between ro and ro(theta)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.objective_fun_theta1">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">objective_fun_theta1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">log_theta1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.objective_fun_theta1" title="Permalink to this definition">¶</a></dt>
<dd><p>Objective function for finding theta1 that gives unit marginal variance.</p>
<p>See Rue and Held 2005, p. 188. They don’t specify how they compute the
value of theta1 to give unit marginal precision so we’ll use scalar
optimization.</p>
<p>!!! Note that Rue and Held use orthonormalized DFT !!!
Parameters
———-
log_theta1 : float</p>
<blockquote>
<div><p>Natural log of value of theta1 to test. Note that since by definition
theta1 must be positive we take the exp of this value so that we 
don’t have to deal with bounds.</p>
</div></blockquote>
<dl class="simple">
<dt>args<span class="classifier">list, [theta, n0, n1]</span></dt><dd><p>Theta is the list of parameters for the GMRF, see block_circ_base
n0, n1 are dimensions of the domain</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>float</dt><dd><p>absolute value of difference between marginal variance and 1</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.radial_spacing">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">radial_spacing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtheta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.025</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dphi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.025</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scanner_height</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.radial_spacing" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes expected spacing between lidar points at distances r.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>r</strong><span class="classifier">ndarray</span></dt><dd><p>(n,) Array of distances to compute spacing for.</p>
</dd>
<dt><strong>dtheta</strong><span class="classifier">float, optional</span></dt><dd><p>Step size in degrees for lidar inclination angle. The default is 0.025.</p>
</dd>
<dt><strong>dphi</strong><span class="classifier">float, optional</span></dt><dd><p>Step size in degrees for lidar azimuth angle. The default is 0.025.</p>
</dd>
<dt><strong>scanner_height</strong><span class="classifier">float, optional</span></dt><dd><p>Height of the scanner above ground in m. The default is 2.5.</p>
</dd>
<dt><strong>slope</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Slope of the surface in degrees in radial direction. If array it must
have the same dimensions as r. The default is 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>(n, 2) Array of spacings at each distance in azimuthal and radial dirs.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.sample_autocorr_2d">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">sample_autocorr_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">samples_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'normal'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nanmode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'zero-fill'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.sample_autocorr_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns autocorrelation fn for evenly spaced 2D sample</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>samples_in</strong><span class="classifier">2D array</span></dt><dd><p>2D array of samples</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>{‘normal’, ‘fourier’, ‘radial’} specifies whether the indices should
be normal (0,0 in middle) or fourier 0-&gt; positive lags
then negative lags -&gt; 0. The default is ‘normal’</p>
</dd>
<dt><strong>nanmode</strong><span class="classifier">str, optional</span></dt><dd><p>if ‘zero-fill’ if the input contains nan’s, zero fill them and adjust
output by multiplicative factor  from Handbook of Spatial Statistics
pg. 71</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>empirical autocorrelation, lag spacing is same as sample spacing</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError: samples must be 2D</dt><dd><p>ValueError: mode must be either ‘normal’ or ‘fourier’</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.theta_to_Q">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">theta_to_Q</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circulant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.theta_to_Q" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sparse matrix Q from the parameters in theta.</p>
<p>If circulant is false we’ll ignore the wrap around terms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n0</strong><span class="classifier">int</span></dt><dd><p>Size of the domain in the row direction.</p>
</dd>
<dt><strong>n1</strong><span class="classifier">int</span></dt><dd><p>Size of the domain in the column direction.</p>
</dd>
<dt><strong>m</strong><span class="classifier">int</span></dt><dd><p>Usually 2 or 3, half width of neighborhood.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">1d-array</span></dt><dd><p>Parameter values of precision matrix, ordered in the same manner as 
Rue and Held 2005 p. 196.</p>
</dd>
<dt><strong>circulant</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to include the wrap-around terms. The default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>(n0*n1)x(n0*n1) sparse matrix</dt><dd><p>The sparse precision matrix Q</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydar.z_alignment_ss">
<span class="sig-prename descclassname"><span class="pre">pydar.</span></span><span class="sig-name descname"><span class="pre">z_alignment_ss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_pt_dens</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_diff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin_reduc_op</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'min'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydar.z_alignment_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Align successive scans on the basis of their gridded minima</p>
<p>ss version is for looking at the change in just a singlescan.
This version is for running outside of the scan_area object.</p>
<p>!This function does not modify the tiepoint locations so it should 
only be run after all tiepoint registration steps are done. It also
requires that there hasn’t been ice deformation and will try to not
run if the fraction that changed by more than the diff cutoff exceeds
frac_exceed_diff_cutoff.
Parameters
———-
project_0 : pydar.Project</p>
<blockquote>
<div><p>The project to align to.</p>
</div></blockquote>
<dl class="simple">
<dt>ss<span class="classifier">pydar.SingleScan</span></dt><dd><p>The singlescan to align</p>
</dd>
<dt>w0<span class="classifier">float, optional</span></dt><dd><p>Grid cell width in x dimension (m). The default is 10.</p>
</dd>
<dt>w1<span class="classifier">float, optional</span></dt><dd><p>Grid cell width in y dimension (m). The default is 10.</p>
</dd>
<dt>min_pt_dens<span class="classifier">float, optional</span></dt><dd><p>minimum density of points/m^2 for us to compare grid cells from
projects 0 and 1. The default is 30.</p>
</dd>
<dt>max_diff<span class="classifier">float, optional</span></dt><dd><p>Maximum difference in minima to consider (higher values must be
noise) in m. The default is 0.1.</p>
</dd>
<dt>bin_reduc_op<span class="classifier">str, optional</span></dt><dd><p>What type of gridded reduction to apply. Options are ‘min’, ‘mean’
and ‘mode’. The default is ‘min’</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>diff</strong><span class="classifier">ndarray</span></dt><dd><p>Array containing gridded minima differences</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">pydar</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, David Clemens-Sewall.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/pydar.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>